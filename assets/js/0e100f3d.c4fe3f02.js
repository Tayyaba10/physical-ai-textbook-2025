"use strict";(globalThis.webpackChunkai_native_robotics_textbook=globalThis.webpackChunkai_native_robotics_textbook||[]).push([[7994],{7668:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"module-1-robotic-nervous-system/ch2-nodes-topics-services-actions","title":"ch2-nodes-topics-services-actions","description":"-----","source":"@site/docs/module-1-robotic-nervous-system/ch2-nodes-topics-services-actions.md","sourceDirName":"module-1-robotic-nervous-system","slug":"/module-1-robotic-nervous-system/ch2-nodes-topics-services-actions","permalink":"/physical-ai-textbook-2025/docs/module-1-robotic-nervous-system/ch2-nodes-topics-services-actions","draft":false,"unlisted":false,"editUrl":"https://github.com/Tayyaba10/physical-ai-textbook-2025/edit/main/docs/module-1-robotic-nervous-system/ch2-nodes-topics-services-actions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"ch1-why-ros2","permalink":"/physical-ai-textbook-2025/docs/module-1-robotic-nervous-system/ch1-why-ros2"},"next":{"title":"ch3-bridging-ai-agents","permalink":"/physical-ai-textbook-2025/docs/module-1-robotic-nervous-system/ch3-bridging-ai-agents"}}');var i=r(4848),c=r(8453),t=r(7242);const a={},o=void 0,l={},d=[{value:"title: Ch2  Nodes, Topics, Services &amp; Actions\r\nmodule: 1\r\nchapter: 2\r\nsidebar_label: Ch2: Nodes, Topics, Services &amp; Actions\r\ndescription: Understanding the fundamental communication patterns in ROS 2\r\ntags: [ros2, nodes, topics, services, actions, communication]\r\ndifficulty: beginner\r\nestimated_duration: 60",id:"title-ch2--nodes-topics-services--actionsmodule-1chapter-2sidebar_label-ch2-nodes-topics-services--actionsdescription-understanding-the-fundamental-communication-patterns-in-ros-2tags-ros2-nodes-topics-services-actions-communicationdifficulty-beginnerestimated_duration-60",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Theory",id:"theory",level:2},{value:"Nodes in ROS 2",id:"nodes-in-ros-2",level:3},{value:"TopicBased Communication",id:"topicbased-communication",level:3},{value:"ServiceBased Communication",id:"servicebased-communication",level:3},{value:"ActionBased Communication",id:"actionbased-communication",level:3},{value:"StepbyStep Labs",id:"stepbystep-labs",level:2},{value:"Lab 1: Creating a Publisher and Subscriber",id:"lab-1-creating-a-publisher-and-subscriber",level:3},{value:"Lab 2: Creating a Service Client and Server",id:"lab-2-creating-a-service-client-and-server",level:3},{value:"Lab 3: Creating an Action Client and Server",id:"lab-3-creating-an-action-client-and-server",level:3},{value:"Runnable Code Example",id:"runnable-code-example",level:2},{value:"Miniproject",id:"miniproject",level:2},{value:"Summary",id:"summary",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"title-ch2--nodes-topics-services--actionsmodule-1chapter-2sidebar_label-ch2-nodes-topics-services--actionsdescription-understanding-the-fundamental-communication-patterns-in-ros-2tags-ros2-nodes-topics-services-actions-communicationdifficulty-beginnerestimated_duration-60",children:"title: Ch2  Nodes, Topics, Services & Actions\r\nmodule: 1\r\nchapter: 2\r\nsidebar_label: Ch2: Nodes, Topics, Services & Actions\r\ndescription: Understanding the fundamental communication patterns in ROS 2\r\ntags: [ros2, nodes, topics, services, actions, communication]\r\ndifficulty: beginner\r\nestimated_duration: 60"}),"\n","\n",(0,i.jsx)(n.h1,{id:"nodes-topics-services--actions",children:"Nodes, Topics, Services & Actions"}),"\n",(0,i.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,i.jsx)(n.p,{children:"Understand the fundamental communication patterns in ROS 2\r\nDistinguish between topics, services, and actions\r\nImplement publishers and subscribers for topicbased communication\r\nImplement clients and servers for servicebased communication\r\nImplement action clients and servers for goaloriented communication\r\nChoose the appropriate communication pattern for different use cases"}),"\n",(0,i.jsx)(n.h2,{id:"theory",children:"Theory"}),"\n",(0,i.jsx)(n.h3,{id:"nodes-in-ros-2",children:"Nodes in ROS 2"}),"\n",(0,i.jsxs)(n.p,{children:["In ROS 2, a ",(0,i.jsx)(n.strong,{children:"node"})," is an executable process that participates in the ROS computation. Nodes are the fundamental building blocks of ROS 2 applications. Each node typically performs a specific task and communicates with other nodes through topics, services, or actions."]}),"\n",(0,i.jsx)(n.p,{children:"Key characteristics of nodes:\r\nEach node has a unique name\r\nNodes can be written in different programming languages (C++, Python, etc.)\r\nNodes can be run independently\r\nNodes contain publishers, subscribers, clients, and services"}),"\n",(0,i.jsx)(n.h3,{id:"topicbased-communication",children:"TopicBased Communication"}),"\n",(0,i.jsx)(t.A,{chart:"\ngraph LR;\n  A[Publisher Node] > B[Topic];\n  C[Subscriber Node] > B;\n  D[Subscriber Node] > B;\n  B > E[Message];\n  style A fill:#4CAF50,stroke:#388E3C,color:#fff;\n  style C fill:#2196F3,stroke:#0D47A1,color:#fff;\n  style D fill:#2196F3,stroke:#0D47A1,color:#fff;\n"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Topics"})," enable asynchronous, decoupled communication between nodes. The communication is manytomany  multiple publishers can send messages to a topic, and multiple subscribers can receive messages from the same topic."]}),"\n",(0,i.jsxs)(n.p,{children:["Characteristics:\r\n",(0,i.jsx)(n.strong,{children:"Asynchronous"}),": Publishers and subscribers don't need to be active at the same time\r\n",(0,i.jsx)(n.strong,{children:"Fireandforget"}),": Publishers send messages without expecting responses\r\n",(0,i.jsx)(n.strong,{children:"Broadcast"}),": One message can be received by multiple subscribers\r\n",(0,i.jsx)(n.strong,{children:"Unidirectional"}),": Data flows in one direction (publisher \u2192 topic \u2192 subscribers)"]}),"\n",(0,i.jsx)(n.h3,{id:"servicebased-communication",children:"ServiceBased Communication"}),"\n",(0,i.jsx)(t.A,{chart:"\ngraph LR;\n  A[Client] > B[Request];\n  B > C[Service Server];\n  C > D[Response];\n  D > A;\n  style A fill:#FF9800,stroke:#E65100,color:#fff;\n  style C fill:#9C27B0,stroke:#4A148C,color:#fff;\n"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Services"})," enable synchronous requestresponse communication between nodes. When a client sends a request to a service, it waits for a response before continuing."]}),"\n",(0,i.jsxs)(n.p,{children:["Characteristics:\r\n",(0,i.jsx)(n.strong,{children:"Synchronous"}),": Client waits for response\r\n",(0,i.jsx)(n.strong,{children:"Requestresponse pattern"}),": One request gets one response\r\n",(0,i.jsx)(n.strong,{children:"Stateless"}),": Each request is independent\r\n",(0,i.jsx)(n.strong,{children:"Suitable for"}),": Tasks that have clear start and end points"]}),"\n",(0,i.jsx)(n.h3,{id:"actionbased-communication",children:"ActionBased Communication"}),"\n",(0,i.jsx)(t.A,{chart:"\ngraph TD;\n  A[Action Client] > B[Send Goal];\n  B > C[Action Server];\n  C > D[Feedback];\n  D > A;\n  C > E[Result];\n  E > A;\n  style A fill:#00BCD4,stroke:#006064,color:#fff;\n  style C fill:#E91E63,stroke:#880E4F,color:#fff;\n"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Actions"})," are used for longrunning tasks that provide feedback during execution and ultimately return a result. They're ideal for tasks like navigation, where you want to track progress."]}),"\n",(0,i.jsxs)(n.p,{children:["Characteristics:\r\n",(0,i.jsx)(n.strong,{children:"Longrunning"}),": Suitable for operations that take significant time\r\n",(0,i.jsx)(n.strong,{children:"Feedback"}),": Provides ongoing feedback during execution\r\n",(0,i.jsx)(n.strong,{children:"Goaloriented"}),": Supports canceling, pausing, and preemption\r\n",(0,i.jsx)(n.strong,{children:"Twoway"}),": Combines requestresponse with continuous feedback"]}),"\n",(0,i.jsx)(n.h2,{id:"stepbystep-labs",children:"StepbyStep Labs"}),"\n",(0,i.jsx)(n.h3,{id:"lab-1-creating-a-publisher-and-subscriber",children:"Lab 1: Creating a Publisher and Subscriber"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Create a new package"})," for your communication examples:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws/src\r\nros2 pkg create buildtype ament_cmake cpp_pubsub\r\ncd cpp_pubsub\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Create a publisher source file"})," (",(0,i.jsx)(n.code,{children:"src/talker.cpp"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include <chrono>\r\n#include <functional>\r\n#include <memory>\r\n#include <string>\r\n\r\n#include "rclcpp/rclcpp.hpp"\r\n#include "std_msgs/msg/string.hpp"\r\n\r\nusing namespace std::chrono_literals;\r\n\r\nclass MinimalPublisher : public rclcpp::Node\r\n{\r\npublic:\r\n  MinimalPublisher()\r\n  : Node("minimal_publisher"), count_(0)\r\n  {\r\n    publisher_ = this>create_publisher<std_msgs::msg::String>("topic", 10);\r\n    timer_ = this>create_wall_timer(\r\n      500ms, std::bind(&MinimalPublisher::timer_callback, this));\r\n  }\r\n\r\nprivate:\r\n  void timer_callback()\r\n  {\r\n    auto message = std_msgs::msg::String();\r\n    message.data = "Hello, world! " + std::to_string(count_++);\r\n    RCLCPP_INFO(this>get_logger(), "Publishing: \'%s\'", message.data.c_str());\r\n    publisher_>publish(message);\r\n  }\r\n  rclcpp::TimerBase::SharedPtr timer_;\r\n  rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;\r\n  size_t count_;\r\n};\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n  rclcpp::init(argc, argv);\r\n  rclcpp::spin(std::make_shared<MinimalPublisher>());\r\n  rclcpp::shutdown();\r\n  return 0;\r\n}\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Create a subscriber source file"})," (",(0,i.jsx)(n.code,{children:"src/listener.cpp"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include <memory>\r\n\r\n#include "rclcpp/rclcpp.hpp"\r\n#include "std_msgs/msg/string.hpp"\r\n\r\nclass MinimalSubscriber : public rclcpp::Node\r\n{\r\npublic:\r\n  MinimalSubscriber()\r\n  : Node("minimal_subscriber")\r\n  {\r\n    subscription_ = this>create_subscription<std_msgs::msg::String>(\r\n      "topic", 10, std::bind(&MinimalSubscriber::topic_callback, this, std::placeholders::_1));\r\n  }\r\n\r\nprivate:\r\n  void topic_callback(const std_msgs::msg::String::SharedPtr msg) const\r\n  {\r\n    RCLCPP_INFO(this>get_logger(), "I heard: \'%s\'", msg>data.c_str());\r\n  }\r\n  rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;\r\n};\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n  rclcpp::init(argc, argv);\r\n  rclcpp::spin(std::make_shared<MinimalSubscriber>());\r\n  rclcpp::shutdown();\r\n  return 0;\r\n}\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Update CMakeLists.txt"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cmake",children:'cmake_minimum_required(VERSION 3.8)\r\nproject(cpp_pubsub)\r\n\r\nif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")\r\n  add_compile_options(Wall Wextra Wpedantic)\r\nendif()\r\n\r\nfind_package(ament_cmake REQUIRED)\r\nfind_package(rclcpp REQUIRED)\r\nfind_package(std_msgs REQUIRED)\r\n\r\nadd_executable(talker src/talker.cpp)\r\nadd_executable(listener src/listener.cpp)\r\n\r\nament_target_dependencies(talker rclcpp std_msgs)\r\nament_target_dependencies(listener rclcpp std_msgs)\r\n\r\ninstall(TARGETS\r\n  talker\r\n  listener\r\n  DESTINATION lib/${PROJECT_NAME})\r\n\r\nament_package()\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"lab-2-creating-a-service-client-and-server",children:"Lab 2: Creating a Service Client and Server"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Create a service definition"})," (",(0,i.jsx)(n.code,{children:"srv/AddTwoInts.srv"}),"):","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-srv",children:"int64 a\r\nint64 b\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"int64 sum"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'\r\n2. **Create a service server** (`src/add_two_ints_server.cpp`):\r\n```cpp\r\n#include "rclcpp/rclcpp.hpp"\r\n#include "example_interfaces/srv/add_two_ints.hpp"\r\n\r\nclass MinimalService : public rclcpp::Node\r\n{\r\npublic:\r\n  MinimalService()\r\n  : Node("minimal_service")\r\n  {\r\n    service_ = this>create_service<example_interfaces::srv::AddTwoInts>(\r\n      "add_two_ints",\r\n      std::bind(&MinimalService::add, this, std::placeholders::_1, std::placeholders::_2));\r\n  }\r\n\r\nprivate:\r\n  void add(const example_interfaces::srv::AddTwoInts::Request::SharedPtr request,\r\n          const example_interfaces::srv::AddTwoInts::Response::SharedPtr response)\r\n  {\r\n    response>sum = request>a + request>b;\r\n    RCLCPP_INFO(rclcpp::get_logger("rclcpp"), "%ld + %ld = %ld",\r\n                request>a, request>b, response>sum);\r\n  }\r\n  rclcpp::Service<example_interfaces::srv::AddTwoInts>::SharedPtr service_;\r\n};\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n  rclcpp::init(argc, argv);\r\n  rclcpp::spin(std::make_shared<MinimalService>());\r\n  rclcpp::shutdown();\r\n  return 0;\r\n}\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Create a service client"})," (",(0,i.jsx)(n.code,{children:"src/add_two_ints_client.cpp"}),"):","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include "rclcpp/rclcpp.hpp"\r\n#include "example_interfaces/srv/add_two_ints.hpp"\r\n\r\n#include <chrono>\r\n#include <cstdlib>\r\n#include <memory>\r\n\r\nusing namespace std::chrono_literals;\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n  rclcpp::init(argc, argv);\r\n\r\n  if (argc != 3) {\r\n      RCLCPP_INFO(rclcpp::get_logger("rclcpp"), "usage: add_two_ints_client X Y");\r\n      return 1;\r\n  }\r\n\r\n  std::shared_ptr<rclcpp::Node> node = rclcpp::Node::make_shared("add_two_ints_client");\r\n  rclcpp::Client<example_interfaces::srv::AddTwoInts>::SharedPtr client =\r\n    node>create_client<example_interfaces::srv::AddTwoInts>("add_two_ints");\r\n\r\n  while (!client>wait_for_service(1s)) {\r\n    if (!rclcpp::ok()) {\r\n      RCLCPP_ERROR(rclcpp::get_logger("rclcpp"), "Interrupted while waiting for the service. Exiting.");\r\n      return 0;\r\n    }\r\n    RCLCPP_INFO(rclcpp::get_logger("rclcpp"), "Service not available, waiting again...");\r\n  }\r\n\r\n  auto request = std::make_shared<example_interfaces::srv::AddTwoInts::Request>();\r\n  request>a = atoll(argv[1]);\r\n  request>b = atoll(argv[2]);\r\n\r\n  auto result = client>async_send_request(request);\r\n  if (rclcpp::spin_until_future_complete(node, result) ==\r\n    rclcpp::FutureReturnCode::SUCCESS)\r\n  {\r\n    RCLCPP_INFO(rclcpp::get_logger("rclcpp"), "%ld + %ld = %ld",\r\n                request>a, request>b, result.get()>sum);\r\n  } else {\r\n    RCLCPP_ERROR(rclcpp::get_logger("rclcpp"), "Failed to call service add_two_ints");\r\n  }\r\n\r\n  rclcpp::shutdown();\r\n  return 0;\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"lab-3-creating-an-action-client-and-server",children:"Lab 3: Creating an Action Client and Server"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Create an action server"})," (",(0,i.jsx)(n.code,{children:"src/fibonacci_action_server.cpp"}),"):","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include <functional>\r\n#include <memory>\r\n#include <thread>\r\n\r\n#include "rclcpp/rclcpp.hpp"\r\n#include "rclcpp_action/rclcpp_action.hpp"\r\n#include "example_interfaces/action/fibonacci.hpp"\r\n\r\nclass FibonacciActionServer : public rclcpp::Node\r\n{\r\npublic:\r\n  using Fibonacci = example_interfaces::action::Fibonacci;\r\n  using GoalHandleFibonacci = rclcpp_action::ServerGoalHandle<Fibonacci>;\r\n\r\n  FibonacciActionServer() : Node("fibonacci_action_server")\r\n  {\r\n    using namespace std::placeholders;\r\n\r\n    action_server_ = rclcpp_action::create_server<Fibonacci>(\r\n      this,\r\n      "fibonacci",\r\n      std::bind(&FibonacciActionServer::handle_goal, this, _1, _2),\r\n      std::bind(&FibonacciActionServer::handle_cancel, this, _1),\r\n      std::bind(&FibonacciActionServer::handle_accepted, this, _1));\r\n  }\r\n\r\nprotected:\r\n  rclcpp_action::GoalResponse handle_goal(\r\n    const rclcpp_action::GoalUUID & uuid,\r\n    std::shared_ptr<const Fibonacci::Goal> goal)\r\n  {\r\n    RCLCPP_INFO(this>get_logger(), "Received goal request with order %d", goal>order);\r\n    (void)uuid;\r\n    return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;\r\n  }\r\n\r\n  rclcpp_action::CancelResponse handle_cancel(\r\n    const std::shared_ptr<GoalHandleFibonacci> goal_handle)\r\n  {\r\n    RCLCPP_INFO(this>get_logger(), "Received request to cancel goal");\r\n    (void)goal_handle;\r\n    return rclcpp_action::CancelResponse::ACCEPT;\r\n  }\r\n\r\n  void handle_accepted(const std::shared_ptr<GoalHandleFibonacci> goal_handle)\r\n  {\r\n    using namespace std::placeholders;\r\n    std::thread{std::bind(&FibonacciActionServer::execute, this, _1), goal_handle}.detach();\r\n  }\r\n\r\nprivate:\r\n  rclcpp_action::Server<Fibonacci>::SharedPtr action_server_;\r\n\r\n  void execute(const std::shared_ptr<GoalHandleFibonacci> goal_handle)\r\n  {\r\n    RCLCPP_INFO(this>get_logger(), "Executing goal");\r\n\r\n    rclcpp::Rate loop_rate(1);\r\n    const auto goal = goal_handle>get_goal();\r\n    auto feedback = std::make_shared<Fibonacci::Feedback>();\r\n    auto result = std::make_shared<Fibonacci::Result>();\r\n\r\n    std::vector<int> sequence = {0, 1};\r\n    feedback>sequence = sequence;\r\n    result>sequence = sequence;\r\n\r\n    for (int i = 1; (i < goal>order) && rclcpp::ok(); ++i) {\r\n      if (goal_handle>is_canceling()) {\r\n        RCLCPP_INFO(this>get_logger(), "Goal canceled");\r\n        result>sequence = sequence;\r\n        goal_handle>canceled(result);\r\n        RCLCPP_INFO(this>get_logger(), "Sending canceled state");\r\n        return;\r\n      }\r\n\r\n      sequence.push_back(sequence[i] + sequence[i  1]);\r\n      feedback>sequence = sequence;\r\n      goal_handle>publish_feedback(feedback);\r\n      RCLCPP_INFO(this>get_logger(), "Publishing feedback");\r\n\r\n      loop_rate.sleep();\r\n    }\r\n\r\n    if (rclcpp::ok()) {\r\n      result>sequence = sequence;\r\n      goal_handle>succeed(result);\r\n      RCLCPP_INFO(this>get_logger(), "Goal succeeded");\r\n    }\r\n  }\r\n};\r\n\r\nint main(int argc, char ** argv)\r\n{\r\n  rclcpp::init(argc, argv);\r\n  auto action_server = std::make_shared<FibonacciActionServer>();\r\n  rclcpp::spin(action_server);\r\n  rclcpp::shutdown();\r\n  return 0;\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"runnable-code-example",children:"Runnable Code Example"}),"\n",(0,i.jsx)(n.p,{children:"Here's a Python example showing all three communication patterns combined:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# combined_communication_example.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.qos import QoSProfile\r\nfrom std_msgs.msg import String\r\nfrom example_interfaces.srv import AddTwoInts\r\nfrom example_interfaces.action import Fibonacci\r\nimport rclpy.action\r\n\r\n\r\nclass CommunicationNode(Node):\r\n    def __init__(self):\r\n        super().__init__('communication_node')\r\n        \r\n        # Topic publisher\r\n        self.publisher = self.create_publisher(String, 'combined_topic', 10)\r\n        \r\n        # Service client\r\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints_client')\r\n        while not self.cli.wait_for_service(timeout_sec=1.0):\r\n            self.get_logger().info('service not available, waiting again...')\r\n        \r\n        # Action client\r\n        self._action_client = rclpy.action.ActionClient(\r\n            self,\r\n            Fibonacci,\r\n            'fibonacci_action_client'\r\n        )\r\n\r\n        # Topic subscriber\r\n        self.subscription = self.create_subscription(\r\n            String,\r\n            'combined_topic',\r\n            self.topic_callback,\r\n            10)\r\n        \r\n        # Timer to trigger all communications\r\n        self.timer = self.create_timer(5.0, self.timer_callback)\r\n    \r\n    def topic_callback(self, msg):\r\n        self.get_logger().info(f'I heard: \"{msg.data}\"')\r\n    \r\n    def timer_callback(self):\r\n        # Publish to topic\r\n        msg = String()\r\n        msg.data = f'Hello, combined communication! Time: {self.get_clock().now().seconds_nanoseconds()}'\r\n        self.publisher.publish(msg)\r\n        \r\n        # Call service\r\n        self.call_service()\r\n        \r\n        # Send action goal\r\n        self.send_action_goal()\r\n    \r\n    def call_service(self):\r\n        request = AddTwoInts.Request()\r\n        request.a = 2\r\n        request.b = 3\r\n        future = self.cli.call_async(request)\r\n        future.add_done_callback(self.service_callback)\r\n    \r\n    def service_callback(self, future):\r\n        result = future.result()\r\n        self.get_logger().info(f'Result of service call: {result.sum}')\r\n    \r\n    def send_action_goal(self):\r\n        goal_msg = Fibonacci.Goal()\r\n        goal_msg.order = 10\r\n        \r\n        self._action_client.wait_for_server()\r\n        send_goal_future = self._action_client.send_goal_async(\r\n            goal_msg,\r\n            feedback_callback=self.feedback_callback)\r\n        \r\n        send_goal_future.add_done_callback(self.goal_response_callback)\r\n    \r\n    def goal_response_callback(self, future):\r\n        goal_handle = future.result()\r\n        if not goal_handle.accepted:\r\n            self.get_logger().info('Goal rejected')\r\n            return\r\n        \r\n        self.get_logger().info('Goal accepted')\r\n        \r\n        get_result_future = goal_handle.get_result_async()\r\n        get_result_future.add_done_callback(self.get_result_callback)\r\n    \r\n    def feedback_callback(self, feedback_msg):\r\n        feedback = feedback_msg.feedback\r\n        self.get_logger().info(f'Received feedback: {feedback.sequence}')\r\n    \r\n    def get_result_callback(self, future):\r\n        result = future.result().result\r\n        self.get_logger().info(f'Final result: {result.sequence}')\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    communication_node = CommunicationNode()\r\n    \r\n    try:\r\n        rclpy.spin(communication_node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        communication_node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"miniproject",children:"Miniproject"}),"\n",(0,i.jsx)(n.p,{children:"Create a ROS 2 package that demonstrates all three communication patterns:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"A publisher that publishes sensor data (temperature, humidity) at regular intervals"}),"\n",(0,i.jsx)(n.li,{children:"A service server that takes a sensor reading and returns whether the reading is within normal range"}),"\n",(0,i.jsx)(n.li,{children:'An action server that simulates a complex task like "moving_to_location" with feedback on progress'}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Create a node that:\r\nPublishes sensor data to the topic\r\nCalls the service to check if readings are normal\r\nSends a goal to an action server to simulate robot movement\r\nSubscribes to a topic to receive status updates"}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"This chapter covered the three fundamental communication patterns in ROS 2:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Topics"}),": For asynchronous, decoupled communication using publishersubscriber model\r\n",(0,i.jsx)(n.strong,{children:"Services"}),": For synchronous requestresponse communication\r\n",(0,i.jsx)(n.strong,{children:"Actions"}),": For longrunning tasks with feedback and goals"]}),"\n",(0,i.jsx)(n.p,{children:"Each communication pattern has its use cases:\r\nUse topics for streaming data or broadcasting information\r\nUse services for tasks with clear inputs and outputs\r\nUse actions for longrunning tasks that provide feedback during execution"}),"\n",(0,i.jsx)(n.p,{children:"Understanding these patterns is crucial for designing wellarchitected ROS 2 systems."})]})}function u(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);