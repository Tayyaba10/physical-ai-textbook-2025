"use strict";(globalThis.webpackChunkai_native_robotics_textbook=globalThis.webpackChunkai_native_robotics_textbook||[]).push([[437],{8241:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>g,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"module-1-robotic-nervous-system/ch3-bridging-ai-agents","title":"ch3-bridging-ai-agents","description":"-----","source":"@site/docs/module-1-robotic-nervous-system/ch3-bridging-ai-agents.md","sourceDirName":"module-1-robotic-nervous-system","slug":"/module-1-robotic-nervous-system/ch3-bridging-ai-agents","permalink":"/physical-ai-textbook-2025/docs/module-1-robotic-nervous-system/ch3-bridging-ai-agents","draft":false,"unlisted":false,"editUrl":"https://github.com/Tayyaba10/physical-ai-textbook-2025/edit/main/docs/module-1-robotic-nervous-system/ch3-bridging-ai-agents.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"ch2-nodes-topics-services-actions","permalink":"/physical-ai-textbook-2025/docs/module-1-robotic-nervous-system/ch2-nodes-topics-services-actions"},"next":{"title":"ch4-urdf-xacro-modeling","permalink":"/physical-ai-textbook-2025/docs/module-1-robotic-nervous-system/ch4-urdf-xacro-modeling"}}');var i=r(4848),t=r(8453),a=r(7242);const o={},l=void 0,c={},d=[{value:"title: Ch3  Bridging Python AI Agents with rclpy\r\nmodule: 1\r\nchapter: 3\r\nsidebar_label: Ch3: Bridging Python AI Agents with rclpy\r\ndescription: Integrating AI algorithms into ROS 2 using Python\r\ntags: [ros2, python, rclpy, ai, machine learning, integration]\r\ndifficulty: intermediate\r\nestimated_duration: 75",id:"title-ch3--bridging-python-ai-agents-with-rclpymodule-1chapter-3sidebar_label-ch3-bridging-python-ai-agents-with-rclpydescription-integrating-ai-algorithms-into-ros-2-using-pythontags-ros2-python-rclpy-ai-machine-learning-integrationdifficulty-intermediateestimated_duration-75",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Theory",id:"theory",level:2},{value:"Python in ROS 2 Ecosystem",id:"python-in-ros-2-ecosystem",level:3},{value:"rclpy Architecture",id:"rclpy-architecture",level:3},{value:"AIROS Integration Patterns",id:"airos-integration-patterns",level:3},{value:"StepbyStep Labs",id:"stepbystep-labs",level:2},{value:"Lab 1: Creating Your First AIROS Node",id:"lab-1-creating-your-first-airos-node",level:3},{value:"Lab 2: Implementing a Machine Learning Node",id:"lab-2-implementing-a-machine-learning-node",level:3},{value:"Lab 3: Creating an AI Decision Node",id:"lab-3-creating-an-ai-decision-node",level:3},{value:"Runnable Code Example",id:"runnable-code-example",level:2},{value:"Additional dependencies for the AI node (setup.cfg):",id:"additional-dependencies-for-the-ai-node-setupcfg",level:3},{value:"Miniproject",id:"miniproject",level:2},{value:"Summary",id:"summary",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"title-ch3--bridging-python-ai-agents-with-rclpymodule-1chapter-3sidebar_label-ch3-bridging-python-ai-agents-with-rclpydescription-integrating-ai-algorithms-into-ros-2-using-pythontags-ros2-python-rclpy-ai-machine-learning-integrationdifficulty-intermediateestimated_duration-75",children:"title: Ch3  Bridging Python AI Agents with rclpy\r\nmodule: 1\r\nchapter: 3\r\nsidebar_label: Ch3: Bridging Python AI Agents with rclpy\r\ndescription: Integrating AI algorithms into ROS 2 using Python\r\ntags: [ros2, python, rclpy, ai, machine learning, integration]\r\ndifficulty: intermediate\r\nestimated_duration: 75"}),"\n","\n",(0,i.jsx)(n.h1,{id:"bridging-python-ai-agents-with-rclpy",children:"Bridging Python AI Agents with rclpy"}),"\n",(0,i.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,i.jsx)(n.p,{children:"Integrate Pythonbased AI algorithms into ROS 2 systems\r\nUnderstand the rclpy library and its API for ROS 2 communication\r\nImplement data exchange between AI algorithms and ROS 2 nodes\r\nDesign nodes that process sensor data with AI algorithms\r\nCreate nodes that execute AIdriven actions\r\nImplement proper error handling in AIROS integration"}),"\n",(0,i.jsx)(n.h2,{id:"theory",children:"Theory"}),"\n",(0,i.jsx)(n.h3,{id:"python-in-ros-2-ecosystem",children:"Python in ROS 2 Ecosystem"}),"\n",(0,i.jsx)(n.p,{children:"Python is one of the primary languages supported in ROS 2, making it an ideal choice for integrating AI algorithms into robotic systems. Python's rich ecosystem of libraries for machine learning, computer vision, and data processing makes it particularly valuable for robotics applications."}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"rclpy"})," library provides the Python client library for ROS 2. It implements the standard ROS 2 concepts (nodes, publishers, subscribers, services, actions) within Python."]}),"\n",(0,i.jsx)(n.h3,{id:"rclpy-architecture",children:"rclpy Architecture"}),"\n",(0,i.jsx)(a.A,{chart:"\ngraph TD;\n  A[rclpy] > B[rclpy.core];\n  A > C[rclpy.node];\n  A > D[rclpy.publisher];\n  A > E[rclpy.subscriber];\n  A > F[rclpy.service];\n  A > G[rclpy.client];\n  A > H[rclpy.action];\n  \n  B > I[rclpy.typesupport];\n  B > J[rclpy.utilities];\n  \n  C > K[Node];\n  D > L[Publisher];\n  E > M[Subscriber];\n  \n  style A fill:#2196F3,stroke:#0D47A1,color:#fff;\n  style K fill:#4CAF50,stroke:#388E3C,color:#fff;\n"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"rclpy"})," library provides a Python interface to the ROS 2 client library (",(0,i.jsx)(n.code,{children:"rcl"}),"), which handles communication with the DDS middleware. This allows Python code to participate in ROS 2 communication patterns seamlessly."]}),"\n",(0,i.jsx)(n.h3,{id:"airos-integration-patterns",children:"AIROS Integration Patterns"}),"\n",(0,i.jsx)(n.p,{children:"Common patterns for integrating AI algorithms with ROS 2 include:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sensor Processing Nodes"}),": Nodes that receive sensor data, process it with AI algorithms, and publish results"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"DecisionMaking Nodes"}),": Nodes that subscribe to multiple data streams, make AIdriven decisions, and publish commands"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Action Execution Nodes"}),": Nodes that execute complex AIdriven tasks with feedback mechanisms"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"stepbystep-labs",children:"StepbyStep Labs"}),"\n",(0,i.jsx)(n.h3,{id:"lab-1-creating-your-first-airos-node",children:"Lab 1: Creating Your First AIROS Node"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Create a new package"})," for AI integration examples:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws/src\r\nros2 pkg create buildtype ament_python py_ai_integration\r\ncd py_ai_integration\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Create the main Python file"})," (",(0,i.jsx)(n.code,{children:"py_ai_integration/sensor_ai_node.py"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nimport numpy as np\r\nfrom std_msgs.msg import Float32MultiArray\r\nfrom sensor_msgs.msg import LaserScan\r\n\r\nclass SensorAINode(Node):\r\n    def __init__(self):\r\n        super().__init__('sensor_ai_node')\r\n        \r\n        # Create subscriber for laser scan data\r\n        self.subscription = self.create_subscription(\r\n            LaserScan,\r\n            'scan',\r\n            self.laser_callback,\r\n            10)\r\n        \r\n        # Create publisher for processed data\r\n        self.publisher = self.create_publisher(\r\n            Float32MultiArray,\r\n            'processed_scan',\r\n            10)\r\n        \r\n        self.get_logger().info('AI Node initialized')\r\n    \r\n    def laser_callback(self, msg):\r\n        # Process the laser scan data using AI algorithms\r\n        ranges = np.array(msg.ranges)\r\n        \r\n        # Remove invalid measurements (inf or nan)\r\n        ranges = np.where(np.isinf(ranges), msg.range_max, ranges)\r\n        ranges = np.nan_to_num(ranges, nan=msg.range_max)\r\n        \r\n        # Detect obstacles using simple thresholding\r\n        obstacle_indices = np.where(ranges < 1.0)[0]  # Objects within 1m\r\n        \r\n        # Calculate some statistics about obstacles\r\n        if len(obstacle_indices) > 0:\r\n            obstacle_angles = [msg.angle_min + i * msg.angle_increment \r\n                              for i in obstacle_indices]\r\n            avg_distance = np.mean(ranges[obstacle_indices])\r\n        else:\r\n            obstacle_angles = []\r\n            avg_distance = msg.range_max\r\n        \r\n        # Prepare AI output\r\n        ai_output = Float32MultiArray()\r\n        ai_output.data = [len(obstacle_indices), avg_distance, \r\n                          len(obstacle_angles), msg.range_max]\r\n        \r\n        # Publish results\r\n        self.publisher.publish(ai_output)\r\n        self.get_logger().info(f'Detected {len(obstacle_indices)} obstacles, avg distance: {avg_distance:.2f}m')\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    sensor_ai_node = SensorAINode()\r\n    \r\n    try:\r\n        rclpy.spin(sensor_ai_node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        sensor_ai_node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Update setup.py"})," to include executables:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from setuptools import setup\r\n\r\npackage_name = 'py_ai_integration'\r\n\r\nsetup(\r\n    name=package_name,\r\n    version='0.0.0',\r\n    packages=[package_name],\r\n    data_files=[\r\n        ('share/ament_index/resource_index/packages',\r\n            ['resource/' + package_name]),\r\n        ('share/' + package_name, ['package.xml']),\r\n    ],\r\n    install_requires=['setuptools'],\r\n    zip_safe=True,\r\n    maintainer='Your Name',\r\n    maintainer_email='your.email@example.com',\r\n    description='AI integration examples for ROS 2',\r\n    license='Apache License 2.0',\r\n    tests_require=['pytest'],\r\n    entry_points={\r\n        'console_scripts': [\r\n            'sensor_ai_node = py_ai_integration.sensor_ai_node:main',\r\n        ],\r\n    },\r\n)\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"lab-2-implementing-a-machine-learning-node",children:"Lab 2: Implementing a Machine Learning Node"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Create a new node"})," for MLbased classification (",(0,i.jsx)(n.code,{children:"py_ai_integration/object_classifier.py"}),"):","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nimport numpy as np\r\nfrom std_msgs.msg import String\r\nfrom sensor_msgs.msg import PointCloud2\r\nfrom sensor_msgs_py import point_cloud2\r\nfrom sklearn.cluster import DBSCAN\r\nimport pickle\r\n\r\nclass ObjectClassifierNode(Node):\r\n    def __init__(self):\r\n        super().__init__('object_classifier_node')\r\n        \r\n        # Create subscriber for point cloud data\r\n        self.subscription = self.create_subscription(\r\n            PointCloud2,\r\n            'pointcloud_input',\r\n            self.pointcloud_callback,\r\n            10)\r\n        \r\n        # Create publisher for classification results\r\n        self.publisher = self.create_publisher(\r\n            String,\r\n            'object_classification',\r\n            10)\r\n        \r\n        # Initialize ML model (in a real application, you'd load a pretrained model)\r\n        self.get_logger().info('Object Classifier Node initialized')\r\n    \r\n    def pointcloud_callback(self, msg):\r\n        # Convert PointCloud2 message to numpy array\r\n        points = np.array(list(point_cloud2.read_points(msg, \r\n                                      field_names=(\"x\", \"y\", \"z\"),\r\n                                      skip_nans=True)))\r\n        \r\n        if len(points) == 0:\r\n            self.get_logger().info('No points in cloud')\r\n            return\r\n        \r\n        # Use DBSCAN clustering to group points\r\n        clustering = DBSCAN(eps=0.3, min_samples=10)\r\n        cluster_labels = clustering.fit_predict(points)\r\n        \r\n        # Count number of clusters (potential objects)\r\n        n_clusters = len(set(cluster_labels))  (1 if 1 in cluster_labels else 0)\r\n        \r\n        # Calculate basic statistics about clusters\r\n        if n_clusters > 0:\r\n            cluster_sizes = []\r\n            for i in range(n_clusters):\r\n                cluster_size = len(cluster_labels[cluster_labels == i])\r\n                cluster_sizes.append(cluster_size)\r\n            \r\n            avg_cluster_size = np.mean(cluster_sizes) if cluster_sizes else 0\r\n        else:\r\n            avg_cluster_size = 0\r\n        \r\n        # Prepare classification result\r\n        result_msg = String()\r\n        result_msg.data = f'Objects detected: {n_clusters}, Avg cluster size: {avg_cluster_size:.2f}'\r\n        \r\n        # Publish results\r\n        self.publisher.publish(result_msg)\r\n        self.get_logger().info(f'Classification result: {result_msg.data}')\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    classifier_node = ObjectClassifierNode()\r\n    \r\n    try:\r\n        rclpy.spin(classifier_node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        classifier_node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"lab-3-creating-an-ai-decision-node",children:"Lab 3: Creating an AI Decision Node"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Create a decisionmaking node"})," (",(0,i.jsx)(n.code,{children:"py_ai_integration/decision_maker.py"}),"):","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nimport numpy as np\r\nfrom std_msgs.msg import String, Bool\r\nfrom geometry_msgs.msg import Twist\r\nfrom sensor_msgs.msg import LaserScan\r\n\r\nclass DecisionMakerNode(Node):\r\n    def __init__(self):\r\n        super().__init__('decision_maker_node')\r\n        \r\n        # Subscribers\r\n        self.laser_sub = self.create_subscription(\r\n            LaserScan,\r\n            'scan',\r\n            self.laser_callback,\r\n            10)\r\n        \r\n        # Publishers\r\n        self.cmd_pub = self.create_publisher(Twist, 'cmd_vel', 10)\r\n        self.alert_pub = self.create_publisher(Bool, 'safety_alert', 10)\r\n        \r\n        # Internal state\r\n        self.obstacle_detected = False\r\n        self.safety_distance = 0.8  # meters\r\n        self.forward_speed = 0.5    # m/s\r\n        \r\n        # Create a timer for decisionmaking loop\r\n        self.timer = self.create_timer(0.1, self.decision_loop)  # 10 Hz\r\n        \r\n        self.get_logger().info('Decision Maker Node initialized')\r\n    \r\n    def laser_callback(self, msg):\r\n        # Process laser scan to detect obstacles\r\n        ranges = np.array(msg.ranges)\r\n        ranges = np.where(np.isinf(ranges), msg.range_max, ranges)\r\n        ranges = np.nan_to_num(ranges, nan=msg.range_max)\r\n        \r\n        # Find the closest obstacle\r\n        min_distance = np.min(ranges)\r\n        self.obstacle_detected = min_distance < self.safety_distance\r\n    \r\n    def decision_loop(self):\r\n        # AIbased decision making\r\n        cmd = Twist()\r\n        \r\n        if self.obstacle_detected:\r\n            # Obstacle detected  stop and turn\r\n            cmd.linear.x = 0.0\r\n            cmd.angular.z = 0.5  # Turn right\r\n            \r\n            # Publish safety alert\r\n            alert_msg = Bool()\r\n            alert_msg.data = True\r\n            self.alert_pub.publish(alert_msg)\r\n            \r\n            self.get_logger().info('Obstacle detected! Stopping and turning...')\r\n        else:\r\n            # No obstacle  move forward\r\n            cmd.linear.x = self.forward_speed\r\n            cmd.angular.z = 0.0\r\n            \r\n            # Publish safety clear\r\n            alert_msg = Bool()\r\n            alert_msg.data = False\r\n            self.alert_pub.publish(alert_msg)\r\n            \r\n            self.get_logger().info('Moving forward...')\r\n        \r\n        # Publish velocity command\r\n        self.cmd_pub.publish(cmd)\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    decision_maker = DecisionMakerNode()\r\n    \r\n    try:\r\n        rclpy.spin(decision_maker)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        decision_maker.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"runnable-code-example",children:"Runnable Code Example"}),"\n",(0,i.jsx)(n.p,{children:"Here's a complete example combining AI and ROS 2 for a simple object recognition task:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# object_recognition_node.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nimport cv2\r\nimport numpy as np\r\nfrom sensor_msgs.msg import Image\r\nfrom std_msgs.msg import String\r\nfrom cv_bridge import CvBridge\r\n\r\nclass ObjectRecognitionNode(Node):\r\n    def __init__(self):\r\n        super().__init__('object_recognition_node')\r\n        \r\n        # Create subscriber for camera images\r\n        self.image_sub = self.create_subscription(\r\n            Image,\r\n            'camera_image',\r\n            self.image_callback,\r\n            10)\r\n        \r\n        # Create publisher for recognition results\r\n        self.result_pub = self.create_publisher(\r\n            String,\r\n            'object_recognition_result',\r\n            10)\r\n        \r\n        # Initialize OpenCV bridge\r\n        self.bridge = CvBridge()\r\n        \r\n        # Simple color detection parameters\r\n        self.lower_red = np.array([0, 50, 50])\r\n        self.upper_red = np.array([10, 255, 255])\r\n        self.lower_red2 = np.array([170, 50, 50])\r\n        self.upper_red2 = np.array([180, 255, 255])\r\n        \r\n        self.get_logger().info('Object Recognition Node initialized')\r\n    \r\n    def image_callback(self, msg):\r\n        try:\r\n            # Convert ROS Image message to OpenCV image\r\n            cv_image = self.bridge.imgmsg_to_cv2(msg, \"bgr8\")\r\n        except Exception as e:\r\n            self.get_logger().error(f'Could not convert image: {str(e)}')\r\n            return\r\n        \r\n        # Convert BGR to HSV for color detection\r\n        hsv = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)\r\n        \r\n        # Create masks for red color\r\n        mask1 = cv2.inRange(hsv, self.lower_red, self.upper_red)\r\n        mask2 = cv2.inRange(hsv, self.lower_red2, self.upper_red2)\r\n        mask = mask1 + mask2\r\n        \r\n        # Apply Gaussian blur to reduce noise\r\n        mask = cv2.GaussianBlur(mask, (9, 9), 2)\r\n        \r\n        # Find contours\r\n        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\r\n        \r\n        # Count red objects (areas larger than threshold)\r\n        red_objects = []\r\n        for contour in contours:\r\n            area = cv2.contourArea(contour)\r\n            if area > 500:  # Filter out small areas\r\n                # Calculate bounding rectangle\r\n                x, y, w, h = cv2.boundingRect(contour)\r\n                red_objects.append({\r\n                    'area': area,\r\n                    'bbox': (x, y, w, h),\r\n                    'center': (x + w//2, y + h//2)\r\n                })\r\n        \r\n        # Publish results\r\n        result_msg = String()\r\n        if len(red_objects) > 0:\r\n            result_msg.data = f\"Detected {len(red_objects)} red objects. Largest area: {max([obj['area'] for obj in red_objects]):.2f}\"\r\n        else:\r\n            result_msg.data = \"No red objects detected\"\r\n        \r\n        self.result_pub.publish(result_msg)\r\n        self.get_logger().info(f'AI result: {result_msg.data}')\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    object_recognition_node = ObjectRecognitionNode()\r\n    \r\n    try:\r\n        rclpy.spin(object_recognition_node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        object_recognition_node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"additional-dependencies-for-the-ai-node-setupcfg",children:"Additional dependencies for the AI node (setup.cfg):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[develop]\r\nscriptdir=$base/lib/py_ai_integration\r\n[install_scripts]\r\ninstall_dir=$base/lib/py_ai_integration\n"})}),"\n",(0,i.jsx)(n.h2,{id:"miniproject",children:"Miniproject"}),"\n",(0,i.jsx)(n.p,{children:"Create a complete AIROS integration project that:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Creates a simulated sensor node that publishes mock sensor data (e.g., temperature, humidity, light levels)"}),"\n",(0,i.jsx)(n.li,{children:"Implements an AI node that uses a machine learning algorithm to predict environmental conditions based on sensor data"}),"\n",(0,i.jsx)(n.li,{children:"Creates a decisionmaking node that takes the AI predictions and sends appropriate commands to simulated actuators"}),"\n",(0,i.jsx)(n.li,{children:"Includes proper error handling and logging"}),"\n",(0,i.jsx)(n.li,{children:"Uses rclpy best practices like proper shutdown and resource cleanup"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Test your system by running all nodes together and verifying the data flows correctly from sensor to AI to decision maker."}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"This chapter introduced the integration of Pythonbased AI algorithms with ROS 2 systems using the rclpy library. Key concepts include:"}),"\n",(0,i.jsx)(n.p,{children:"The rclpy library serves as the Python client library for ROS 2\r\nCommon patterns for AIROS integration include sensor processing, decisionmaking, and action execution\r\nProper error handling and resource management are essential for robust AIROS systems\r\nThe Python ecosystem provides rich support for AI algorithms that can be easily integrated into ROS 2"}),"\n",(0,i.jsx)(n.p,{children:"Successfully bridging AI algorithms with ROS 2 enables the development of intelligent robotic systems that can perceive, reason, and act in complex environments."})]})}function g(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);