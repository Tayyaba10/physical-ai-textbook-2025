"use strict";(globalThis.webpackChunkai_native_robotics_textbook=globalThis.webpackChunkai_native_robotics_textbook||[]).push([[6317],{7925:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-2-digital-twin/ch6-physics-simulation","title":"ch6-physics-simulation","description":"-----","source":"@site/docs/module-2-digital-twin/ch6-physics-simulation.md","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/ch6-physics-simulation","permalink":"/physical-ai-textbook-2025/docs/module-2-digital-twin/ch6-physics-simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/Tayyaba10/physical-ai-textbook-2025/edit/main/docs/module-2-digital-twin/ch6-physics-simulation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"ch5-building-launching-packages","permalink":"/physical-ai-textbook-2025/docs/module-1-robotic-nervous-system/ch5-building-launching-packages"},"next":{"title":"ch7-gazebo-ignition-setup-building","permalink":"/physical-ai-textbook-2025/docs/module-2-digital-twin/ch7-gazebo-ignition-setup-building"}}');var r=i(4848),a=i(8453),l=i(7242);const s={},o=void 0,d={},c=[{value:"title: Ch6  Physics Simulation Fundamentals\r\nmodule: 2\r\nchapter: 6\r\nsidebar_label: Ch6: Physics Simulation Fundamentals\r\ndescription: Understanding the principles of physics simulation for robotic systems\r\ntags: [simulation, physics, robotics, dynamics, kinematics, gazebo]\r\ndifficulty: intermediate\r\nestimated_duration: 75",id:"title-ch6--physics-simulation-fundamentalsmodule-2chapter-6sidebar_label-ch6-physics-simulation-fundamentalsdescription-understanding-the-principles-of-physics-simulation-for-robotic-systemstags-simulation-physics-robotics-dynamics-kinematics-gazebodifficulty-intermediateestimated_duration-75",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Theory",id:"theory",level:2},{value:"Introduction to Physics Simulation",id:"introduction-to-physics-simulation",level:3},{value:"Kinematics vs Dynamics",id:"kinematics-vs-dynamics",level:3},{value:"Mathematical Models",id:"mathematical-models",level:3},{value:"Rigid Body Dynamics",id:"rigid-body-dynamics",level:4},{value:"Configuration Space (CSpace)",id:"configuration-space-cspace",level:4},{value:"Collision Detection",id:"collision-detection",level:3},{value:"Integration Methods",id:"integration-methods",level:3},{value:"StepbyStep Labs",id:"stepbystep-labs",level:2},{value:"Lab 1: Understanding Kinematic vs Dynamic Simulation",id:"lab-1-understanding-kinematic-vs-dynamic-simulation",level:3},{value:"Lab 2: Implementing Forward Dynamics for a Simple Robot",id:"lab-2-implementing-forward-dynamics-for-a-simple-robot",level:3},{value:"Lab 3: Understanding Numerical Integration Stability",id:"lab-3-understanding-numerical-integration-stability",level:3},{value:"Runnable Code Example",id:"runnable-code-example",level:2},{value:"Miniproject",id:"miniproject",level:2},{value:"Summary",id:"summary",level:2}];function m(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"title-ch6--physics-simulation-fundamentalsmodule-2chapter-6sidebar_label-ch6-physics-simulation-fundamentalsdescription-understanding-the-principles-of-physics-simulation-for-robotic-systemstags-simulation-physics-robotics-dynamics-kinematics-gazebodifficulty-intermediateestimated_duration-75",children:"title: Ch6  Physics Simulation Fundamentals\r\nmodule: 2\r\nchapter: 6\r\nsidebar_label: Ch6: Physics Simulation Fundamentals\r\ndescription: Understanding the principles of physics simulation for robotic systems\r\ntags: [simulation, physics, robotics, dynamics, kinematics, gazebo]\r\ndifficulty: intermediate\r\nestimated_duration: 75"}),"\n","\n",(0,r.jsx)(e.h1,{id:"physics-simulation-fundamentals",children:"Physics Simulation Fundamentals"}),"\n",(0,r.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,r.jsx)(e.p,{children:"Understand the core principles of physics simulation\r\nExplain the differences between kinematic and dynamic simulation\r\nIdentify the mathematical models underlying physics simulation\r\nUnderstand the concepts of collision detection and response\r\nRecognize the importance of simulation in robotics development\r\nApply physics simulation concepts to robotic systems\r\nEvaluate the tradeoffs between simulation accuracy and computational efficiency"}),"\n",(0,r.jsx)(e.h2,{id:"theory",children:"Theory"}),"\n",(0,r.jsx)(e.h3,{id:"introduction-to-physics-simulation",children:"Introduction to Physics Simulation"}),"\n",(0,r.jsx)(e.p,{children:"Physics simulation is a computational method for approximating the behavior of physical systems. In robotics, physics simulation is crucial for testing algorithms, validating designs, and generating training data for AI systems before deploying on real hardware."}),"\n",(0,r.jsx)(l.A,{chart:"\ngraph TD;\n  A[Physics Simulation] > B[Kinematic Simulation];\n  A > C[Dynamic Simulation];\n  B > D[Position Only];\n  B > E[No Forces];\n  C > F[Position + Velocity];\n  C > G[Forces];\n  C > H[Mass];\n  C > I[Inertia];\n  \n  J[Simulation Pipeline] > K[Model Definition];\n  K > L[Physics Engine];\n  L > M[Collision Detection];\n  M > N[Force Calculation];\n  N > O[Integration];\n  O > P[State Update];\n  \n  style A fill:#4CAF50,stroke:#388E3C,color:#fff;\n  style L fill:#2196F3,stroke:#0D47A1,color:#fff;\n"}),"\n",(0,r.jsx)(e.h3,{id:"kinematics-vs-dynamics",children:"Kinematics vs Dynamics"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Kinematics"})," studies motion without considering the forces that cause it. It focuses on geometric relationships between position, velocity, and acceleration:"]}),"\n",(0,r.jsx)(e.p,{children:"Forward kinematics: given joint angles, find endeffector position\r\nInverse kinematics: given endeffector position, find required joint angles"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Dynamics"})," studies motion considering the forces and torques that cause it:"]}),"\n",(0,r.jsx)(e.p,{children:"Inverse dynamics: given motion, find required forces/torques\r\nForward dynamics: given forces/torques, find resulting motion"}),"\n",(0,r.jsx)(e.h3,{id:"mathematical-models",children:"Mathematical Models"}),"\n",(0,r.jsx)(e.h4,{id:"rigid-body-dynamics",children:"Rigid Body Dynamics"}),"\n",(0,r.jsx)(e.p,{children:"The motion of a rigid body is governed by NewtonEuler equations:"}),"\n",(0,r.jsx)(e.p,{children:"For translational motion:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"F = m * a\n"})}),"\n",(0,r.jsx)(e.p,{children:"For rotational motion:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"\u03c4 = I * \u03b1\n"})}),"\n",(0,r.jsx)(e.p,{children:"Where:\r\nF: Force vector\r\nm: Mass\r\na: Linear acceleration\r\n\u03c4: Torque vector\r\nI: Moment of inertia tensor\r\n\u03b1: Angular acceleration"}),"\n",(0,r.jsx)(e.h4,{id:"configuration-space-cspace",children:"Configuration Space (CSpace)"}),"\n",(0,r.jsx)(e.p,{children:"Configuration space is the space of all possible positions/poses for a robot. For a robot with n degrees of freedom, the configuration space is ndimensional:"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"C = R^n"})," for n revolute joints with no limits\r\n",(0,r.jsx)(e.code,{children:"C = T^n"})," for n revolute joints with 2\u03c0 periodicity\r\n",(0,r.jsx)(e.code,{children:"C = SE(3)"})," for a freefloating body"]}),"\n",(0,r.jsx)(e.h3,{id:"collision-detection",children:"Collision Detection"}),"\n",(0,r.jsx)(e.p,{children:"Physics simulation requires efficient algorithms to detect when objects come into contact:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Broad Phase"}),": Quickly eliminate pairs of objects that cannot possibly collide (e.g., using bounding volume hierarchies)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Narrow Phase"}),": Perform detailed collision detection between potentially colliding objects"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Contact Resolution"}),": Calculate contact points, normals, and penetration depth"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"integration-methods",children:"Integration Methods"}),"\n",(0,r.jsx)(e.p,{children:"Physics simulation uses numerical integration to solve differential equations of motion. Common methods include:"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Explicit Euler"}),": Simple but unstable for stiff systems\r\n",(0,r.jsx)(e.strong,{children:"Semiimplicit Euler"}),": More stable than explicit Euler\r\n",(0,r.jsx)(e.strong,{children:"RungeKutta (RK4)"}),": More accurate but computationally expensive\r\n",(0,r.jsx)(e.strong,{children:"Verlet Integration"}),": Good for stability in positionbased systems"]}),"\n",(0,r.jsx)(e.h2,{id:"stepbystep-labs",children:"StepbyStep Labs"}),"\n",(0,r.jsx)(e.h3,{id:"lab-1-understanding-kinematic-vs-dynamic-simulation",children:"Lab 1: Understanding Kinematic vs Dynamic Simulation"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Create a simple pendulum simulation"})," to visualize the difference between kinematic and dynamic models:"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.animation import FuncAnimation\r\n\r\n# Physical constants\r\ng = 9.81  # gravitational acceleration\r\nL = 1.0   # length of pendulum\r\nm = 1.0   # mass of pendulum\r\n\r\ndef simple_pendulum_simulate(dt=0.01, duration=10, initial_angle=0.5, initial_velocity=0.0):\r\n    \"\"\"\r\n    Simulate a simple pendulum using the small angle approximation (kinematic)\r\n    and full nonlinear dynamics (dynamic)\r\n    \"\"\"\r\n    # Time array\r\n    t = np.arange(0, duration, dt)\r\n    n_points = len(t)\r\n    \r\n    # Kinematic solution (small angle approximation): theta = theta_0 * cos(omega * t)\r\n    omega = np.sqrt(g / L)\r\n    kinematic_theta = initial_angle * np.cos(omega * t)\r\n    kinematic_omega = initial_angle * omega * np.sin(omega * t)\r\n    \r\n    # Dynamic solution using Euler integration\r\n    dynamic_theta = np.zeros(n_points)\r\n    dynamic_omega = np.zeros(n_points)\r\n    dynamic_theta[0] = initial_angle\r\n    dynamic_omega[0] = initial_velocity\r\n    \r\n    # Euler integration\r\n    for i in range(1, n_points):\r\n        # Angular acceleration: alpha = g/L * sin(theta)\r\n        alpha = g/L * np.sin(dynamic_theta[i1])\r\n        \r\n        # Update state\r\n        dynamic_omega[i] = dynamic_omega[i1] + alpha * dt\r\n        dynamic_theta[i] = dynamic_theta[i1] + dynamic_omega[i] * dt\r\n    \r\n    # Calculate positions\r\n    kinematic_x = L * np.sin(kinematic_theta)\r\n    kinematic_y = L * np.cos(kinematic_theta)\r\n    \r\n    dynamic_x = L * np.sin(dynamic_theta)\r\n    dynamic_y = L * np.cos(dynamic_theta)\r\n    \r\n    return t, (kinematic_x, kinematic_y, kinematic_theta), (dynamic_x, dynamic_y, dynamic_theta)\r\n\r\n# Run simulation\r\nt, kinematic_data, dynamic_data = simple_pendulum_simulate()\r\n\r\n# Plot results\r\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\r\n\r\n# Plot angle vs time\r\nax1.plot(t, kinematic_data[2], label='Kinematic (Small Angle)', linestyle='')\r\nax1.plot(t, dynamic_data[2], label='Dynamic (Nonlinear)')\r\nax1.set_xlabel('Time (s)')\r\nax1.set_ylabel('Angle (rad)')\r\nax1.set_title('Pendulum Angle vs Time')\r\nax1.legend()\r\nax1.grid(True)\r\n\r\n# Plot position vs time\r\nax2.plot(t, kinematic_data[0], label='Kinematic X', linestyle='')\r\nax2.plot(t, kinematic_data[1], label='Kinematic Y', linestyle='')\r\nax2.plot(t, dynamic_data[0], label='Dynamic X')\r\nax2.plot(t, dynamic_data[1], label='Dynamic Y')\r\nax2.set_xlabel('Time (s)')\r\nax2.set_ylabel('Position (m)')\r\nax2.set_title('Pendulum Position vs Time')\r\nax2.legend()\r\nax2.grid(True)\r\n\r\nplt.tight_layout()\r\nplt.show()\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Analyze the differences"})," in the simulation outputs:\r\nCompare linear vs. nonlinear behavior\r\nNote how the kinematic model (small angle approximation) deviates from the dynamic model with larger initial angles\r\nObserve energy conservation in the dynamic model"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"lab-2-implementing-forward-dynamics-for-a-simple-robot",children:"Lab 2: Implementing Forward Dynamics for a Simple Robot"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Create a simulation of a 2DOF planar manipulator"}),":"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'import numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nclass TwoDOFManipulator:\r\n    def __init__(self, l1=1.0, l2=0.8, m1=1.0, m2=1.0, I1=0.1, I2=0.1):\r\n        """\r\n        2DOF Planar Manipulator\r\n        l1, l2: link lengths\r\n        m1, m2: link masses\r\n        I1, I2: moments of inertia\r\n        """\r\n        self.l1 = l1\r\n        self.l2 = l2\r\n        self.m1 = m1\r\n        self.m2 = m2\r\n        self.I1 = I1\r\n        self.I2 = I2\r\n        \r\n    def forward_kinematics(self, q1, q2):\r\n        """Calculate endeffector position given joint angles"""\r\n        x1 = self.l1 * np.cos(q1)\r\n        y1 = self.l1 * np.sin(q1)\r\n        \r\n        x2 = x1 + self.l2 * np.cos(q1 + q2)\r\n        y2 = y1 + self.l2 * np.sin(q1 + q2)\r\n        \r\n        return x1, y1, x2, y2\r\n    \r\n    def jacobian(self, q1, q2):\r\n        """Calculate the Jacobian matrix"""\r\n        J = np.array([\r\n            [self.l1*np.sin(q1)  self.l2*np.sin(q1+q2), self.l2*np.sin(q1+q2)],\r\n            [self.l1*np.cos(q1) + self.l2*np.cos(q1+q2), self.l2*np.cos(q1+q2)]\r\n        ])\r\n        return J\r\n    \r\n    def mass_matrix(self, q1, q2):\r\n        """Calculate the mass matrix H(q)"""\r\n        H11 = self.I1 + self.I2 + self.m1*(self.l1/2)**2 + self.m2*((self.l1*np.cos(q1) + self.l2*np.cos(q1+q2)/2)**2 + (self.l1*np.sin(q1) + self.l2*np.sin(q1+q2)/2)**2)\r\n        H12 = self.I2 + self.m2*(self.l1*self.l2*np.cos(q2)/2 + (self.l2/2)**2)\r\n        H21 = H12\r\n        H22 = self.I2 + self.m2*(self.l2/2)**2\r\n        \r\n        H = np.array([[H11, H12],\r\n                      [H21, H22]])\r\n        return H\r\n    \r\n    def coriolis_gravity_matrix(self, q1, q2, q1_dot, q2_dot):\r\n        """Calculate C(q, q_dot), G(q) matrices"""\r\n        # Simplified version  full form is more complex\r\n        C11 = self.m2*self.l1*self.l2*np.sin(q2)*(q2_dot + 2*q1_dot)\r\n        C12 = self.m2*self.l1*self.l2*np.sin(q2)*q1_dot\r\n        C21 = self.m2*self.l1*self.l2*np.sin(q2)*q1_dot\r\n        C22 = 0\r\n        \r\n        # Gravity terms\r\n        g = 9.81\r\n        G1 = (self.m1*self.l1/2 + self.m2*self.l1)*g*np.cos(q1) + self.m2*self.l2*g*np.cos(q1+q2)\r\n        G2 = self.m2*self.l2*g*np.cos(q1+q2)\r\n        \r\n        C = np.array([[C11, C12],\r\n                      [C21, C22]])\r\n        G = np.array([G1, G2])\r\n        \r\n        return C, G\r\n\r\ndef simulate_manipulator(duration=10, dt=0.01):\r\n    """Simulate the manipulator with applied torques"""\r\n    manipulator = TwoDOFManipulator()\r\n    \r\n    # Time array\r\n    t = np.arange(0, duration, dt)\r\n    n_steps = len(t)\r\n    \r\n    # Initialize state\r\n    q = np.array([np.pi/4, np.pi/4])  # Joint angles\r\n    q_dot = np.array([0.0, 0.0])      # Joint velocities\r\n    tau = np.array([0.5, 0.3])        # Applied torques\r\n    \r\n    # Store trajectory\r\n    q_history = []\r\n    pos_history = []\r\n    \r\n    for i in range(n_steps):\r\n        # Store current state\r\n        q_history.append(q.copy())\r\n        \r\n        # Calculate positions\r\n        x1, y1, x2, y2 = manipulator.forward_kinematics(q[0], q[1])\r\n        pos_history.append([x1, y1, x2, y2])\r\n        \r\n        # Calculate dynamics\r\n        H = manipulator.mass_matrix(q[0], q[1])\r\n        C, G = manipulator.coriolis_gravity_matrix(q[0], q[1], q_dot[0], q_dot[1])\r\n        \r\n        # Equation: H(q) * q_ddot + C(q, q_dot) * q_dot + G(q) = tau\r\n        q_ddot = np.linalg.solve(H, tau  C @ q_dot  G)\r\n        \r\n        # Integrate\r\n        q_dot += q_ddot * dt\r\n        q += q_dot * dt\r\n    \r\n    return t, np.array(q_history), np.array(pos_history)\r\n\r\n# Run simulation\r\nt, q_traj, pos_traj = simulate_manipulator()\r\n\r\n# Plot results\r\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\r\n\r\n# Plot joint angles\r\nax1.plot(t, q_traj[:, 0], label=\'Joint 1\')\r\nax1.plot(t, q_traj[:, 1], label=\'Joint 2\')\r\nax1.set_xlabel(\'Time (s)\')\r\nax1.set_ylabel(\'Angle (rad)\')\r\nax1.set_title(\'Joint Angles vs Time\')\r\nax1.legend()\r\nax1.grid(True)\r\n\r\n# Plot endeffector trajectory\r\nax2.plot(pos_traj[:, 2], pos_traj[:, 3], \'b\', label=\'Endeffector path\')\r\nax2.plot(pos_traj[0, 2], pos_traj[0, 3], \'go\', label=\'Start\')\r\nax2.plot(pos_traj[1, 2], pos_traj[1, 3], \'ro\', label=\'End\')\r\nax2.set_xlabel(\'X Position (m)\')\r\nax2.set_ylabel(\'Y Position (m)\')\r\nax2.set_title(\'EndEffector Trajectory\')\r\nax2.legend()\r\nax2.grid(True)\r\nax2.axis(\'equal\')\r\n\r\nplt.tight_layout()\r\nplt.show()\n'})}),"\n",(0,r.jsx)(e.h3,{id:"lab-3-understanding-numerical-integration-stability",children:"Lab 3: Understanding Numerical Integration Stability"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Compare different integration methods"})," for a simple harmonic oscillator:"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\ndef simple_harmonic_oscillator_implicit_euler(x0, v0, k, m, dt, duration):\r\n    \"\"\"Solve SHM using implicit Euler method\"\"\"\r\n    t = np.arange(0, duration, dt)\r\n    x = np.zeros_like(t)\r\n    v = np.zeros_like(t)\r\n    \r\n    x[0] = x0\r\n    v[0] = v0\r\n    \r\n    for i in range(1, len(t)):\r\n        # Implicit Euler: x_{n+1} = x_n + dt * v_{n+1}, v_{n+1} = v_n + dt * (k/m * x_{n+1})\r\n        # Solve simultaneously: (x_{n+1}  x_n)/dt = v_{n+1}, (v_{n+1}  v_n)/dt = k/m * x_{n+1}\r\n        # Rearranging: x_{n+1}  dt*v_{n+1} = x_n, v_{n+1} + dt*(k/m)*x_{n+1} = v_n\r\n        \r\n        A = np.array([[1, dt],\r\n                      [dt*(k/m), 1]])\r\n        b = np.array([x[i1], v[i1]])\r\n        \r\n        sol = np.linalg.solve(A, b)\r\n        x[i] = sol[0]\r\n        v[i] = sol[1]\r\n        \r\n    return t, x, v\r\n\r\ndef simple_harmonic_oscillator_explicit_euler(x0, v0, k, m, dt, duration):\r\n    \"\"\"Solve SHM using explicit Euler method\"\"\"\r\n    t = np.arange(0, duration, dt)\r\n    x = np.zeros_like(t)\r\n    v = np.zeros_like(t)\r\n    \r\n    x[0] = x0\r\n    v[0] = v0\r\n    \r\n    for i in range(1, len(t)):\r\n        # Harmonic oscillator: dx/dt = v, dv/dt = k/m * x\r\n        dx_dt = v[i1]\r\n        dv_dt = (k/m) * x[i1]\r\n        \r\n        x[i] = x[i1] + dx_dt * dt\r\n        v[i] = v[i1] + dv_dt * dt\r\n        \r\n    return t, x, v\r\n\r\ndef simple_harmonic_oscillator_rk4(x0, v0, k, m, dt, duration):\r\n    \"\"\"Solve SHM using RungeKutta 4th order method\"\"\"\r\n    t = np.arange(0, duration, dt)\r\n    x = np.zeros_like(t)\r\n    v = np.zeros_like(t)\r\n    \r\n    x[0] = x0\r\n    v[0] = v0\r\n    \r\n    for i in range(1, len(t)):\r\n        # Define derivatives\r\n        def dx_dt(v_val):\r\n            return v_val\r\n        def dv_dt(x_val):\r\n            return (k/m) * x_val\r\n        \r\n        # RK4 coefficients for x\r\n        k1_x = dt * dx_dt(v[i1])\r\n        k2_x = dt * dx_dt(v[i1] + 0.5 * dt * dv_dt(x[i1]))\r\n        k3_x = dt * dx_dt(v[i1] + 0.5 * dt * dv_dt(x[i1] + 0.5*k2_x))\r\n        k4_x = dt * dx_dt(v[i1] + dt * dv_dt(x[i1] + 0.5*k3_x))\r\n        \r\n        # RK4 coefficients for v\r\n        k1_v = dt * dv_dt(x[i1])\r\n        k2_v = dt * dv_dt(x[i1] + 0.5*k1_x)\r\n        k3_v = dt * dv_dt(x[i1] + 0.5*k2_x)\r\n        k4_v = dt * dv_dt(x[i1] + k3_x)\r\n        \r\n        x[i] = x[i1] + (k1_x + 2*k2_x + 2*k3_x + k4_x) / 6\r\n        v[i] = v[i1] + (k1_v + 2*k2_v + 2*k3_v + k4_v) / 6\r\n        \r\n    return t, x, v\r\n\r\n# Parameters\r\nk = 1.0  # Spring constant\r\nm = 1.0  # Mass\r\nx0 = 1.0 # Initial position\r\nv0 = 0.0 # Initial velocity\r\ndt = 0.01\r\nduration = 20.0\r\n\r\n# Run simulations\r\nt_imp, x_imp, v_imp = simple_harmonic_oscillator_implicit_euler(x0, v0, k, m, dt, duration)\r\nt_exp, x_exp, v_exp = simple_harmonic_oscillator_explicit_euler(x0, v0, k, m, dt, duration)\r\nt_rk4, x_rk4, v_rk4 = simple_harmonic_oscillator_rk4(x0, v0, k, m, dt, duration)\r\n\r\n# Plot results\r\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 12))\r\n\r\n# Plot position vs time\r\nax1.plot(t_imp, x_imp, label='Implicit Euler', alpha=0.7)\r\nax1.plot(t_exp, x_exp, label='Explicit Euler', alpha=0.7)\r\nax1.plot(t_rk4, x_rk4, label='RK4', alpha=0.7)\r\nax1.set_ylabel('Position')\r\nax1.set_title('Simple Harmonic Motion  Different Integration Methods')\r\nax1.legend()\r\nax1.grid(True)\r\n\r\n# Plot velocity vs time\r\nax2.plot(t_imp, v_imp, label='Implicit Euler', alpha=0.7)\r\nax2.plot(t_exp, v_exp, label='Explicit Euler', alpha=0.7)\r\nax2.plot(t_rk4, v_rk4, label='RK4', alpha=0.7)\r\nax2.set_ylabel('Velocity')\r\nax2.set_xlabel('Time (s)')\r\nax2.legend()\r\nax2.grid(True)\r\n\r\n# Phase plot (position vs velocity)\r\nax3.plot(x_imp, v_imp, label='Implicit Euler', alpha=0.7)\r\nax3.plot(x_exp, v_exp, label='Explicit Euler', alpha=0.7)\r\nax3.plot(x_rk4, v_rk4, label='RK4', alpha=0.7)\r\nax3.set_xlabel('Position')\r\nax3.set_ylabel('Velocity')\r\nax3.set_title('Phase Plot')\r\nax3.legend()\r\nax3.grid(True)\r\n\r\nplt.tight_layout()\r\nplt.show()\n"})}),"\n",(0,r.jsx)(e.h2,{id:"runnable-code-example",children:"Runnable Code Example"}),"\n",(0,r.jsx)(e.p,{children:"Here's a complete simulation of a double pendulum that demonstrates chaotic behavior:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.animation import FuncAnimation\r\n\r\nclass DoublePendulum:\r\n    def __init__(self, m1=1.0, m2=1.0, l1=1.0, l2=1.0, g=9.81):\r\n        self.m1 = m1  # Mass of first pendulum\r\n        self.m2 = m2  # Mass of second pendulum\r\n        self.l1 = l1  # Length of first pendulum\r\n        self.l2 = l2  # Length of second pendulum\r\n        self.g = g    # Gravitational acceleration\r\n    \r\n    def equations_of_motion(self, t, state):\r\n        \"\"\"\r\n        Equations of motion for double pendulum\r\n        state = [theta1, omega1, theta2, omega2]\r\n        \"\"\"\r\n        theta1, omega1, theta2, omega2 = state\r\n        \r\n        # Precompute some values\r\n        cos_delta = np.cos(theta1  theta2)\r\n        sin_delta = np.sin(theta1  theta2)\r\n        \r\n        # Denominator for angular acceleration equations\r\n        denom = (self.m1 + self.m2) * self.l1  self.m2 * self.l1 * cos_delta * cos_delta\r\n        \r\n        # Angular acceleration for theta1\r\n        theta1_ddot = (self.m2 * self.g * self.l2 * sin_delta * cos_delta  \r\n                      self.m2 * self.l1 * omega1 * omega1 * sin_delta * cos_delta + \r\n                      self.m2 * self.g * self.l2 * np.sin(theta2)  \r\n                      self.m2 * self.l2 * omega2 * omega2 * sin_delta) / denom\r\n        \r\n        # Angular acceleration for theta2\r\n        theta2_ddot = ((self.m1 + self.m2) * self.g * np.sin(theta1) * cos_delta  \r\n                      (self.m1 + self.m2) * self.l1 * omega1 * omega1 * sin_delta  \r\n                      (self.m1 + self.m2) * self.g * np.sin(theta2) + \r\n                      self.m2 * self.l2 * omega2 * omega2 * sin_delta * cos_delta) / (denom * self.l2 / self.l1)\r\n        \r\n        return [omega1, theta1_ddot, omega2, theta2_ddot]\r\n\r\ndef simulate_double_pendulum(initial_conditions, duration=20, dt=0.01):\r\n    \"\"\"\r\n    Simulate double pendulum using 4thorder RungeKutta integration\r\n    \"\"\"\r\n    t = np.arange(0, duration, dt)\r\n    n_steps = len(t)\r\n    \r\n    # Initialize state array\r\n    state = np.zeros((n_steps, 4))  # [theta1, omega1, theta2, omega2]\r\n    state[0] = initial_conditions\r\n    \r\n    # Create instance of double pendulum\r\n    pendulum = DoublePendulum()\r\n    \r\n    # RK4 integration\r\n    for i in range(1, n_steps):\r\n        # Get current state\r\n        current_state = state[i1]\r\n        current_time = t[i1]\r\n        \r\n        # RK4 coefficients\r\n        k1 = dt * np.array(pendulum.equations_of_motion(current_time, current_state))\r\n        k2 = dt * np.array(pendulum.equations_of_motion(current_time + dt/2, current_state + k1/2))\r\n        k3 = dt * np.array(pendulum.equations_of_motion(current_time + dt/2, current_state + k2/2))\r\n        k4 = dt * np.array(pendulum.equations_of_motion(current_time + dt, current_state + k3))\r\n        \r\n        # Update state\r\n        state[i] = current_state + (k1 + 2*k2 + 2*k3 + k4) / 6\r\n    \r\n    # Calculate positions of pendulum bobs\r\n    x1 = pendulum.l1 * np.sin(state[:, 0])\r\n    y1 = pendulum.l1 * np.cos(state[:, 0])\r\n    \r\n    x2 = x1 + pendulum.l2 * np.sin(state[:, 2])\r\n    y2 = y1  pendulum.l2 * np.cos(state[:, 2])\r\n    \r\n    return t, state, x1, y1, x2, y2\r\n\r\n# Simulation parameters\r\ninitial_conditions = [np.pi/2, 0, np.pi/2, 0]  # [theta1, omega1, theta2, omega2]\r\nt, state, x1, y1, x2, y2 = simulate_double_pendulum(initial_conditions)\r\n\r\n# Plot results\r\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))\r\n\r\n# Plot angles over time\r\nax1.plot(t, state[:, 0], label='\u03b8\u2081', linewidth=2)\r\nax1.plot(t, state[:, 2], label='\u03b8\u2082', linewidth=2)\r\nax1.set_xlabel('Time (s)')\r\nax1.set_ylabel('Angle (rad)')\r\nax1.set_title('Double Pendulum: Angles vs Time')\r\nax1.legend()\r\nax1.grid(True)\r\n\r\n# Plot trajectory of second mass\r\nax2.plot(x2, y2, 'r', alpha=0.7, label='Path of second mass')\r\nax2.plot([0, x1[0]], [0, y1[0]], 'bo', markersize=10, label='Initial position', linewidth=3)\r\nax2.plot([x1[0], x2[0]], [y1[0], y2[0]], 'ro', markersize=12, linewidth=3)\r\nax2.plot(x2[1], y2[1], 'rs', markersize=10, label='Final position')\r\nax2.set_xlabel('X Position (m)')\r\nax2.set_ylabel('Y Position (m)')\r\nax2.set_title('Double Pendulum: Trajectory of Second Mass')\r\nax2.legend()\r\nax2.grid(True)\r\nax2.axis('equal')\r\n\r\nplt.tight_layout()\r\nplt.show()\r\n\r\n# Animation of the double pendulum\r\nfig, ax = plt.subplots(figsize=(8, 8))\r\nline, = ax.plot([], [], 'o', lw=2, markersize=8)\r\ntrace, = ax.plot([], [], 'r', alpha=0.5, linewidth=1)\r\n\r\n# Set up the axes\r\nax.set_xlim(2.5, 2.5)\r\nax.set_ylim(2.5, 0.5)\r\nax.set_xlabel('X position')\r\nax.set_ylabel('Y position')\r\nax.set_title('Double Pendulum Animation')\r\nax.grid(True)\r\n\r\ndef init():\r\n    line.set_data([], [])\r\n    trace.set_data([], [])\r\n    return line, trace\r\n\r\ndef animate(i):\r\n    # Draw the pendulum\r\n    x_vals = [0, x1[i], x2[i]]\r\n    y_vals = [0, y1[i], y2[i]]\r\n    line.set_data(x_vals, y_vals)\r\n    \r\n    # Draw the trace of the second mass\r\n    trace.set_data(x2[:i+1], y2[:i+1])\r\n    \r\n    return line, trace\r\n\r\n# Create animation\r\nanim = FuncAnimation(fig, animate, init_func=init, frames=len(t), interval=20, blit=True, repeat=True)\r\nplt.show()\r\n\r\nprint(f\"Simulation completed for {len(t)} time steps over {t[1]:.2f} seconds\")\n"})}),"\n",(0,r.jsx)(e.h2,{id:"miniproject",children:"Miniproject"}),"\n",(0,r.jsx)(e.p,{children:"Create a physics simulation of a differential drive robot that includes:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"A model of the robot's kinematics and dynamics"}),"\n",(0,r.jsx)(e.li,{children:"Implementation of collision detection with walls/obstacles"}),"\n",(0,r.jsx)(e.li,{children:"A simple control algorithm (e.g., to follow a trajectory)"}),"\n",(0,r.jsx)(e.li,{children:"Visualization of the robot's motion and environment"}),"\n",(0,r.jsx)(e.li,{children:"Performance analysis comparing different integration methods"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Your simulation should include:\r\nDifferential drive kinematic model\r\nIntegration of motion equations\r\nObstacle representation and collision detection\r\nVisualization of robot trajectory\r\nAnalysis of energy conservation or other physical properties"}),"\n",(0,r.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(e.p,{children:"This chapter introduced the fundamentals of physics simulation in robotics:"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Kinematics vs. Dynamics"}),": Understanding the difference between positionbased and forcebased motion simulation\r\n",(0,r.jsx)(e.strong,{children:"Mathematical Models"}),": The core equations governing rigid body motion\r\n",(0,r.jsx)(e.strong,{children:"Integration Methods"}),": Numerical techniques for solving differential equations of motion\r\n",(0,r.jsx)(e.strong,{children:"Collision Detection"}),": Methods for identifying when objects make contact\r\n",(0,r.jsx)(e.strong,{children:"Stability Considerations"}),": Tradeoffs between accuracy and computational efficiency"]}),"\n",(0,r.jsx)(e.p,{children:"Physics simulation is essential for robotics development, allowing engineers to test algorithms, validate designs, and train AI systems in a safe, costeffective virtual environment before deployment on real hardware."})]})}function p(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(m,{...n})}):m(n)}}}]);