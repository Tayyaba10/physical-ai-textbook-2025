"use strict";(globalThis.webpackChunkai_native_robotics_textbook=globalThis.webpackChunkai_native_robotics_textbook||[]).push([[9919],{5393:(n,r,e)=>{e.r(r),e.d(r,{assets:()=>c,contentTitle:()=>l,default:()=>g,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"module-2-digital-twin/ch9-unity-hdrp-visualization","title":"ch9-unity-hdrp-visualization","description":"-----","source":"@site/docs/module-2-digital-twin/ch9-unity-hdrp-visualization.md","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/ch9-unity-hdrp-visualization","permalink":"/physical-ai-textbook-2025/docs/module-2-digital-twin/ch9-unity-hdrp-visualization","draft":false,"unlisted":false,"editUrl":"https://github.com/Tayyaba10/physical-ai-textbook-2025/edit/main/docs/module-2-digital-twin/ch9-unity-hdrp-visualization.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"ch8-simulating-sensors","permalink":"/physical-ai-textbook-2025/docs/module-2-digital-twin/ch8-simulating-sensors"},"next":{"title":"ch10-debugging-simulations","permalink":"/physical-ai-textbook-2025/docs/module-2-digital-twin/ch10-debugging-simulations"}}');var i=e(4848),o=e(8453),a=e(7242);const s={},l=void 0,c={},d=[{value:"title: Ch9  Unity HDRP Visualization &amp; HRI\r\nmodule: 2\r\nchapter: 9\r\nsidebar_label: Ch9: Unity HDRP Visualization &amp; HRI\r\ndescription: Creating highfidelity visualizations with Unity HDRP and implementing HumanRobot Interaction\r\ntags: [unity, hdrp, visualization, hri, humanrobotinteraction, graphics, simulation]\r\ndifficulty: advanced\r\nestimated_duration: 120",id:"title-ch9--unity-hdrp-visualization--hrimodule-2chapter-9sidebar_label-ch9-unity-hdrp-visualization--hridescription-creating-highfidelity-visualizations-with-unity-hdrp-and-implementing-humanrobot-interactiontags-unity-hdrp-visualization-hri-humanrobotinteraction-graphics-simulationdifficulty-advancedestimated_duration-120",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Theory",id:"theory",level:2},{value:"Unity HDRP Overview",id:"unity-hdrp-overview",level:3},{value:"HumanRobot Interaction (HRI) Principles",id:"humanrobot-interaction-hri-principles",level:3},{value:"UnityROS Integration",id:"unityros-integration",level:3},{value:"StepbyStep Labs",id:"stepbystep-labs",level:2},{value:"Lab 1: Setting up Unity HDRP Project",id:"lab-1-setting-up-unity-hdrp-project",level:3},{value:"Lab 2: Creating a Robot Visualization",id:"lab-2-creating-a-robot-visualization",level:3},{value:"Lab 3: Implementing HumanRobot Interaction Interface",id:"lab-3-implementing-humanrobot-interaction-interface",level:3},{value:"Lab 4: ROS Integration (Conceptual)",id:"lab-4-ros-integration-conceptual",level:3},{value:"Runnable Code Example",id:"runnable-code-example",level:2},{value:"Unity Scene Setup for Robotics Visualization",id:"unity-scene-setup-for-robotics-visualization",level:3},{value:"HRI Dashboard Example (<code>HRIDashboard.cs</code>)",id:"hri-dashboard-example-hridashboardcs",level:3},{value:"Miniproject",id:"miniproject",level:2},{value:"Summary",id:"summary",level:2}];function u(n){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"title-ch9--unity-hdrp-visualization--hrimodule-2chapter-9sidebar_label-ch9-unity-hdrp-visualization--hridescription-creating-highfidelity-visualizations-with-unity-hdrp-and-implementing-humanrobot-interactiontags-unity-hdrp-visualization-hri-humanrobotinteraction-graphics-simulationdifficulty-advancedestimated_duration-120",children:"title: Ch9  Unity HDRP Visualization & HRI\r\nmodule: 2\r\nchapter: 9\r\nsidebar_label: Ch9: Unity HDRP Visualization & HRI\r\ndescription: Creating highfidelity visualizations with Unity HDRP and implementing HumanRobot Interaction\r\ntags: [unity, hdrp, visualization, hri, humanrobotinteraction, graphics, simulation]\r\ndifficulty: advanced\r\nestimated_duration: 120"}),"\n","\n",(0,i.jsx)(r.h1,{id:"unity-hdrp-visualization--hri",children:"Unity HDRP Visualization & HRI"}),"\n",(0,i.jsx)(r.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,i.jsx)(r.p,{children:"Understand Unity HDRP (High Definition Render Pipeline) for photorealistic visualization\r\nCreate highfidelity robotic simulation environments in Unity\r\nImplement HumanRobot Interaction (HRI) interfaces\r\nIntegrate Unity with ROS 2 for bidirectional communication\r\nDesign intuitive user interfaces for robot control and monitoring\r\nOptimize Unity scenes for realtime performance with complex robotics scenarios\r\nImplement VR/AR interfaces for enhanced HumanRobot Interaction"}),"\n",(0,i.jsx)(r.h2,{id:"theory",children:"Theory"}),"\n",(0,i.jsx)(r.h3,{id:"unity-hdrp-overview",children:"Unity HDRP Overview"}),"\n",(0,i.jsx)(r.p,{children:"The High Definition Render Pipeline (HDRP) is Unity's modern rendering pipeline designed for highfidelity graphics. It offers advanced features like:"}),"\n",(0,i.jsx)(a.A,{chart:"\ngraph TD;\n  A[Unity HDRP] > B[Photorealistic Rendering];\n  A > C[Global Illumination];\n  A > D[Advanced Lighting];\n  A > E[PostProcessing];\n  \n  B > F[Realistic Materials];\n  B > G[Accurate Reflections];\n  C > H[Volumetric Lighting];\n  C > I[Light Transport];\n  D > J[Physical Cameras];\n  D > K[Realtime Shadows];\n  E > L[Color Grading];\n  E > M[AntiAliasing];\n  \n  style A fill:#4CAF50,stroke:#388E3C,color:#fff;\n  style B fill:#2196F3,stroke:#0D47A1,color:#fff;\n"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"PhysicallyBased Shading (PBS)"}),": Materials that respond realistically to lighting conditions\r\n",(0,i.jsx)(r.strong,{children:"Global Illumination"}),": Realistic light scattering and bounce lighting\r\n",(0,i.jsx)(r.strong,{children:"Volumetric Lighting"}),": Realistic light rays and atmospheric effects\r\n",(0,i.jsx)(r.strong,{children:"Realtime Ray Tracing"}),": Accurate reflections and shadows\r\n",(0,i.jsx)(r.strong,{children:"Advanced PostProcessing Effects"}),": Color grading, depth of field, motion blur"]}),"\n",(0,i.jsx)(r.h3,{id:"humanrobot-interaction-hri-principles",children:"HumanRobot Interaction (HRI) Principles"}),"\n",(0,i.jsx)(r.p,{children:"HRI in Unity simulation environments involves creating intuitive interfaces that allow humans to interact with robots in realistic scenarios:"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Visual Feedback"}),": Clear representation of robot state, intentions, and status\r\n",(0,i.jsx)(r.strong,{children:"Intuitive Controls"}),": Natural and responsive interfaces for commanding robots\r\n",(0,i.jsx)(r.strong,{children:"Situation Awareness"}),": Providing users with necessary environmental and robot information\r\n",(0,i.jsx)(r.strong,{children:"Safety Considerations"}),": Interfaces that promote safe humanrobot collaboration"]}),"\n",(0,i.jsx)(r.h3,{id:"unityros-integration",children:"UnityROS Integration"}),"\n",(0,i.jsx)(r.p,{children:"Unity can communicate with ROS 2 through various approaches:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"ROS# Library"}),": Direct integration allowing Unity to act as a ROS node"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"WebSocket Bridge"}),": Communication via web sockets"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"TCP/UDP Bridge"}),": Direct socket communication"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"ROS Bridge Package"}),": Using the official ROS Bridge package"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"stepbystep-labs",children:"StepbyStep Labs"}),"\n",(0,i.jsx)(r.h3,{id:"lab-1-setting-up-unity-hdrp-project",children:"Lab 1: Setting up Unity HDRP Project"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Create a new Unity HDRP project"}),':\r\nOpen Unity Hub\r\nCreate new project\r\nSelect "3D (High Definition Render Pipeline)" template\r\nOr create a 3D project and convert to HDRP later']}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Configure the HDRP asset"}),":\r\nCreate an HDRP asset in your Assets folder\r\nConfigure settings like lighting, postprocessing, and performance parameters"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Basic HDRP setup script"})," (",(0,i.jsx)(r.code,{children:"HDRPSetup.cs"}),"):"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'using UnityEngine;\r\nusing UnityEngine.Rendering;\r\nusing UnityEngine.Rendering.HighDefinition;\r\n\r\npublic class HDRPSetup : MonoBehaviour\r\n{\r\n    [Header("Lighting Settings")]\r\n    public float globalLightIntensity = 3.14f;\r\n    public Color globalLightColor = Color.white;\r\n    \r\n    [Header("PostProcessing Settings")]\r\n    public bool useBloom = true;\r\n    public float bloomIntensity = 0.5f;\r\n    public bool useDepthOfField = true;\r\n    \r\n    private HDAdditionalLightData mainLightData;\r\n    private HDAdditionalCameraData cameraData;\r\n    \r\n    void Start()\r\n    {\r\n        SetupLighting();\r\n        SetupCamera();\r\n        SetupPostProcessing();\r\n    }\r\n    \r\n    void SetupLighting()\r\n    {\r\n        // Find the main directional light\r\n        Light mainLight = RenderSettings.sun;\r\n        if (mainLight != null)\r\n        {\r\n            mainLightData = mainLight.GetComponent<HDAdditionalLightData>();\r\n            if (mainLightData != null)\r\n            {\r\n                mainLight.intensity = globalLightIntensity;\r\n                mainLight.color = globalLightColor;\r\n                mainLightData.SetHDAdditionalLightData(HDLightType.Directional, globalLightIntensity, globalLightColor);\r\n            }\r\n        }\r\n    }\r\n    \r\n    void SetupCamera()\r\n    {\r\n        Camera mainCamera = Camera.main;\r\n        if (mainCamera != null)\r\n        {\r\n            cameraData = mainCamera.GetComponent<HDAdditionalCameraData>();\r\n            if (cameraData != null)\r\n            {\r\n                // Configure camera settings for simulation\r\n                cameraData.customRenderingSettings = true;\r\n                cameraData.renderingPath = RenderingPath.HighDefinition;\r\n            }\r\n        }\r\n    }\r\n    \r\n    void SetupPostProcessing()\r\n    {\r\n        // Apply postprocessing settings\r\n        if (useBloom)\r\n        {\r\n            // Bloom settings would be configured here\r\n            // This is a simplified example  actual implementation would use Volume components\r\n        }\r\n    }\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"lab-2-creating-a-robot-visualization",children:"Lab 2: Creating a Robot Visualization"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Create a basic robot model"})," in Unity:\r\nUse primitives (cylinders, cubes, spheres) to create a simple robot\r\nOr import a 3D model of a robot"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Create robot controller script"})," (",(0,i.jsx)(r.code,{children:"RobotController.cs"}),"):"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'using UnityEngine;\r\n\r\n[System.Serializable]\r\npublic class JointConfig\r\n{\r\n    public string jointName;\r\n    public float minAngle = 90f;\r\n    public float maxAngle = 90f;\r\n    public float currentAngle = 0f;\r\n}\r\n\r\npublic class RobotController : MonoBehaviour\r\n{\r\n    [Header("Robot Configuration")]\r\n    public JointConfig[] joints;\r\n    \r\n    [Header("Visual Components")]\r\n    public Material defaultMaterial;\r\n    public Material selectedMaterial;\r\n    public Renderer[] robotParts;\r\n    \r\n    [Header("Simulation Parameters")]\r\n    public float movementSpeed = 1.0f;\r\n    public float rotationSpeed = 50.0f;\r\n    \r\n    private bool isConnected = false;\r\n    \r\n    void Start()\r\n    {\r\n        InitializeRobot();\r\n    }\r\n    \r\n    void Update()\r\n    {\r\n        // Update joint positions based on config\r\n        UpdateJointPositions();\r\n        \r\n        // Handle robot movement if connected to simulation\r\n        if (isConnected)\r\n        {\r\n            ProcessSimulationInputs();\r\n        }\r\n    }\r\n    \r\n    void InitializeRobot()\r\n    {\r\n        // Initialize joints with default values\r\n        for (int i = 0; i < joints.Length; i++)\r\n        {\r\n            joints[i].currentAngle = 0f;\r\n        }\r\n    }\r\n    \r\n    void UpdateJointPositions()\r\n    {\r\n        // This would typically be called with data from ROS\r\n        // For now, we\'ll just apply the stored angles\r\n        for (int i = 0; i < joints.Length; i++)\r\n        {\r\n            Transform jointTransform = FindChildByName(joints[i].jointName);\r\n            if (jointTransform != null)\r\n            {\r\n                // Apply rotation based on joint configuration\r\n                Vector3 rotation = jointTransform.localEulerAngles;\r\n                // This is a simplification  real implementation would need to know which axis to rotate\r\n                jointTransform.localEulerAngles = new Vector3(rotation.x, rotation.y, joints[i].currentAngle);\r\n            }\r\n        }\r\n    }\r\n    \r\n    Transform FindChildByName(string name)\r\n    {\r\n        Transform[] children = GetComponentsInChildren<Transform>();\r\n        foreach (Transform child in children)\r\n        {\r\n            if (child.name == name)\r\n                return child;\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    public void SetJointAngle(string jointName, float angle)\r\n    {\r\n        for (int i = 0; i < joints.Length; i++)\r\n        {\r\n            if (joints[i].jointName == jointName)\r\n            {\r\n                joints[i].currentAngle = Mathf.Clamp(angle, joints[i].minAngle, joints[i].maxAngle);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    public void ConnectToSimulation()\r\n    {\r\n        isConnected = true;\r\n    }\r\n    \r\n    public void DisconnectFromSimulation()\r\n    {\r\n        isConnected = false;\r\n    }\r\n    \r\n    void ProcessSimulationInputs()\r\n    {\r\n        // This would handle inputs from ROS simulation\r\n        // For now, just a placeholder\r\n    }\r\n    \r\n    // Visualization of robot state\r\n    public void HighlightRobot()\r\n    {\r\n        if (robotParts != null)\r\n        {\r\n            foreach (Renderer part in robotParts)\r\n            {\r\n                if (part != null)\r\n                {\r\n                    part.material = selectedMaterial;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    public void ResetRobotVisuals()\r\n    {\r\n        if (robotParts != null)\r\n        {\r\n            foreach (Renderer part in robotParts)\r\n            {\r\n                if (part != null)\r\n                {\r\n                    part.material = defaultMaterial;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"lab-3-implementing-humanrobot-interaction-interface",children:"Lab 3: Implementing HumanRobot Interaction Interface"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Create HRI UI controller"})," (",(0,i.jsx)(r.code,{children:"HRIController.cs"}),"):","\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'using UnityEngine;\r\nusing UnityEngine.UI;\r\nusing TMPro;\r\n\r\npublic class HRIController : MonoBehaviour\r\n{\r\n    [Header("UI Elements")]\r\n    public Button connectButton;\r\n    public Button disconnectButton;\r\n    public Button moveForwardButton;\r\n    public Button moveBackwardButton;\r\n    public Button turnLeftButton;\r\n    public Button turnRightButton;\r\n    public Slider speedSlider;\r\n    public TextMeshProUGUI statusText;\r\n    public TextMeshProUGUI jointStatusText;\r\n    \r\n    [Header("Robot Reference")]\r\n    public RobotController robot;\r\n    \r\n    [Header("Command Parameters")]\r\n    public float linearSpeed = 1.0f;\r\n    public float angularSpeed = 1.0f;\r\n    \r\n    void Start()\r\n    {\r\n        SetupUI();\r\n    }\r\n    \r\n    void SetupUI()\r\n    {\r\n        if (connectButton != null)\r\n            connectButton.onClick.AddListener(ConnectToRobot);\r\n            \r\n        if (disconnectButton != null)\r\n            disconnectButton.onClick.AddListener(DisconnectFromRobot);\r\n            \r\n        if (moveForwardButton != null)\r\n            moveForwardButton.onClick.AddListener(MoveForward);\r\n            \r\n        if (moveBackwardButton != null)\r\n            moveBackwardButton.onClick.AddListener(MoveBackward);\r\n            \r\n        if (turnLeftButton != null)\r\n            turnLeftButton.onClick.AddListener(TurnLeft);\r\n            \r\n        if (turnRightButton != null)\r\n            turnRightButton.onClick.AddListener(TurnRight);\r\n            \r\n        if (speedSlider != null)\r\n            speedSlider.onValueChanged.AddListener(UpdateSpeed);\r\n    }\r\n    \r\n    void ConnectToRobot()\r\n    {\r\n        if (robot != null)\r\n        {\r\n            robot.ConnectToSimulation();\r\n            UpdateStatus("Connected to robot");\r\n        }\r\n    }\r\n    \r\n    void DisconnectFromRobot()\r\n    {\r\n        if (robot != null)\r\n        {\r\n            robot.DisconnectFromSimulation();\r\n            UpdateStatus("Disconnected from robot");\r\n        }\r\n    }\r\n    \r\n    void MoveForward()\r\n    {\r\n        if (robot != null && robot.GetComponent<Rigidbody>() != null)\r\n        {\r\n            Rigidbody rb = robot.GetComponent<Rigidbody>();\r\n            rb.AddForce(robot.transform.forward * linearSpeed, ForceMode.VelocityChange);\r\n            UpdateStatus("Moving forward");\r\n        }\r\n    }\r\n    \r\n    void MoveBackward()\r\n    {\r\n        if (robot != null && robot.GetComponent<Rigidbody>() != null)\r\n        {\r\n            Rigidbody rb = robot.GetComponent<Rigidbody>();\r\n            rb.AddForce(robot.transform.forward * linearSpeed, ForceMode.VelocityChange);\r\n            UpdateStatus("Moving backward");\r\n        }\r\n    }\r\n    \r\n    void TurnLeft()\r\n    {\r\n        if (robot != null)\r\n        {\r\n            robot.transform.Rotate(Vector3.up, angularSpeed * Time.deltaTime, Space.World);\r\n            UpdateStatus("Turning left");\r\n        }\r\n    }\r\n    \r\n    void TurnRight()\r\n    {\r\n        if (robot != null)\r\n        {\r\n            robot.transform.Rotate(Vector3.up, angularSpeed * Time.deltaTime, Space.World);\r\n            UpdateStatus("Turning right");\r\n        }\r\n    }\r\n    \r\n    void UpdateSpeed(float newSpeed)\r\n    {\r\n        linearSpeed = newSpeed;\r\n        angularSpeed = newSpeed;\r\n        UpdateStatus($"Speed updated: {newSpeed:F2}");\r\n    }\r\n    \r\n    void UpdateStatus(string status)\r\n    {\r\n        if (statusText != null)\r\n        {\r\n            statusText.text = $"Status: {status}";\r\n        }\r\n    }\r\n    \r\n    void UpdateJointStatus()\r\n    {\r\n        if (jointStatusText != null && robot != null)\r\n        {\r\n            string jointInfo = "Joint Status:\\n";\r\n            foreach (var joint in robot.joints)\r\n            {\r\n                jointInfo += $"{joint.jointName}: {joint.currentAngle:F2}\xb0\\n";\r\n            }\r\n            jointStatusText.text = jointInfo;\r\n        }\r\n    }\r\n    \r\n    void Update()\r\n    {\r\n        // Update joint status continuously\r\n        UpdateJointStatus();\r\n    }\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"lab-4-ros-integration-conceptual",children:"Lab 4: ROS Integration (Conceptual)"}),"\n",(0,i.jsx)(r.p,{children:"While Unity doesn't have native ROS support, here's a conceptual implementation showing how you might integrate with ROS:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"ROS Communication Manager"})," (",(0,i.jsx)(r.code,{children:"ROSCommunicationManager.cs"}),"):","\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'using System.Collections;\r\nusing System.Collections.Generic;\r\nusing UnityEngine;\r\nusing System.Net.WebSockets;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing System.Text;\r\n\r\n// This is a simplified example  a real implementation would require more sophisticated networking\r\npublic class ROSCommunicationManager : MonoBehaviour\r\n{\r\n    [Header("ROS Connection Settings")]\r\n    public string rosBridgeUrl = "ws://localhost:9090";\r\n    public float updateRate = 10.0f;  // Hz\r\n    \r\n    private ClientWebSocket webSocket;\r\n    private bool isConnected = false;\r\n    private CancellationTokenSource cancellationTokenSource;\r\n    \r\n    [Header("Robot Reference")]\r\n    public RobotController robotController;\r\n    \r\n    void Start()\r\n    {\r\n        ConnectToROSBridge();\r\n    }\r\n    \r\n    async void ConnectToROSBridge()\r\n    {\r\n        try\r\n        {\r\n            webSocket = new ClientWebSocket();\r\n            cancellationTokenSource = new CancellationTokenSource();\r\n            \r\n            await webSocket.ConnectAsync(new System.Uri(rosBridgeUrl), cancellationTokenSource.Token);\r\n            isConnected = true;\r\n            \r\n            // Start receiving messages\r\n            StartCoroutine(ReceiveMessages());\r\n            \r\n            Debug.Log("Connected to ROS Bridge");\r\n        }\r\n        catch (System.Exception e)\r\n        {\r\n            Debug.LogError($"Failed to connect to ROS Bridge: {e.Message}");\r\n        }\r\n    }\r\n    \r\n    IEnumerator ReceiveMessages()\r\n    {\r\n        // This would run continuously to receive messages from ROS\r\n        while (isConnected && webSocket.State == WebSocketState.Open)\r\n        {\r\n            // In a real implementation, you would receive ROS messages here\r\n            // and update the Unity scene accordingly\r\n            \r\n            // For now, just simulate receiving joint states\r\n            if (robotController != null)\r\n            {\r\n                // Simulate receiving joint state data\r\n                SimulateJointStateUpdate();\r\n            }\r\n            \r\n            yield return new WaitForSeconds(1.0f / updateRate);\r\n        }\r\n    }\r\n    \r\n    void SimulateJointStateUpdate()\r\n    {\r\n        // Simulate updating robot joints based on ROS messages\r\n        if (robotController != null)\r\n        {\r\n            // In a real implementation, this would process actual ROS JointState messages\r\n            // For simulation, we\'ll just update with realistic values\r\n            foreach (var joint in robotController.joints)\r\n            {\r\n                // Add small random changes to simulate real robot movement\r\n                joint.currentAngle += Random.Range(2f, 2f);\r\n                joint.currentAngle = Mathf.Clamp(joint.currentAngle, joint.minAngle, joint.maxAngle);\r\n            }\r\n        }\r\n    }\r\n    \r\n    async void SendCommand(string topic, string message)\r\n    {\r\n        if (isConnected && webSocket.State == WebSocketState.Open)\r\n        {\r\n            byte[] messageBytes = Encoding.UTF8.GetBytes(message);\r\n            await webSocket.SendAsync(new ArraySegment<byte>(messageBytes), WebSocketMessageType.Text, true, cancellationTokenSource.Token);\r\n        }\r\n    }\r\n    \r\n    void OnApplicationQuit()\r\n    {\r\n        if (cancellationTokenSource != null)\r\n        {\r\n            cancellationTokenSource.Cancel();\r\n        }\r\n        \r\n        if (webSocket != null)\r\n        {\r\n            webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Application closing", CancellationToken.None);\r\n        }\r\n    }\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"runnable-code-example",children:"Runnable Code Example"}),"\n",(0,i.jsx)(r.p,{children:"Here's a complete example of a Unitybased visualization system for a robotic arm:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'using UnityEngine;\r\nusing UnityEngine.Rendering.HighDefinition;\r\nusing System.Collections.Generic;\r\n\r\n// Main class to manage the robotic arm visualization\r\npublic class RoboticArmVisualizer : MonoBehaviour\r\n{-\r\n    [Header("Arm Configuration")]\r\n    public Transform baseJoint;      // Base of the arm\r\n    public Transform[] joints;       // All joints of the arm\r\n    public Transform[] links;        // All links of the arm\r\n    public Transform endEffector;    // End effector of the arm\r\n    \r\n    [Header("Joint Limits")]\r\n    public float[] minJointAngles = new float[6];\r\n    public float[] maxJointAngles = new float[6];\r\n    public float[] currentJointAngles = new float[6];\r\n    \r\n    [Header("Visualization Parameters")]\r\n    public Material defaultMaterial;\r\n    public Material selectedMaterial;\r\n    public float animationSpeed = 5f;\r\n    public bool useIK = false;\r\n    \r\n    [Header("Target Tracking")]\r\n    public Transform targetObject;\r\n    public bool trackTarget = false;\r\n    \r\n    private List<Renderer> armRenderers = new List<Renderer>();\r\n    private bool isAnimating = false;\r\n    \r\n    void Start()\r\n    {\r\n        InitializeArm();\r\n        SetupMaterials();\r\n    }\r\n    \r\n    void Update()\r\n    {\r\n        if (trackTarget && targetObject != null)\r\n        {\r\n            UpdateArmToTarget();\r\n        }\r\n        else if (!isAnimating)\r\n        {\r\n            UpdateArmPosition();\r\n        }\r\n    }\r\n    \r\n    void InitializeArm()\r\n    {\r\n        // Initialize joint angles\r\n        for (int i = 0; i < currentJointAngles.Length; i++)\r\n        {\r\n            if (i < joints.Length)\r\n            {\r\n                currentJointAngles[i] = joints[i].localEulerAngles.y;  // Assuming rotation around Y axis\r\n            }\r\n        }\r\n        \r\n        // Collect all renderers for material changes\r\n        armRenderers.AddRange(GetComponentsInChildren<Renderer>());\r\n    }\r\n    \r\n    void SetupMaterials()\r\n    {\r\n        if (defaultMaterial != null)\r\n        {\r\n            foreach (Renderer renderer in armRenderers)\r\n            {\r\n                if (renderer != null)\r\n                {\r\n                    renderer.material = defaultMaterial;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    public void SetJointAngles(float[] angles)\r\n    {\r\n        if (angles.Length == currentJointAngles.Length)\r\n        {\r\n            for (int i = 0; i < angles.Length; i++)\r\n            {\r\n                currentJointAngles[i] = Mathf.Clamp(angles[i], minJointAngles[i], maxJointAngles[i]);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            Debug.LogWarning("Joint angle array size mismatch");\r\n        }\r\n    }\r\n    \r\n    public void SetJointAngle(int jointIndex, float angle)\r\n    {\r\n        if (jointIndex >= 0 && jointIndex < currentJointAngles.Length)\r\n        {\r\n            currentJointAngles[jointIndex] = Mathf.Clamp(angle, minJointAngles[jointIndex], maxJointAngles[jointIndex]);\r\n        }\r\n    }\r\n    \r\n    void UpdateArmPosition()\r\n    {\r\n        // Update each joint based on its target angle\r\n        for (int i = 0; i < joints.Length && i < currentJointAngles.Length; i++)\r\n        {\r\n            if (joints[i] != null)\r\n            {\r\n                // Animate joint rotation towards target angle\r\n                Vector3 currentRotation = joints[i].localEulerAngles;\r\n                \r\n                // Calculate new angle with smooth interpolation\r\n                float newAngle = Mathf.LerpAngle(\r\n                    currentRotation.y, \r\n                    currentJointAngles[i], \r\n                    Time.deltaTime * animationSpeed\r\n                );\r\n                \r\n                joints[i].localEulerAngles = new Vector3(currentRotation.x, newAngle, currentRotation.z);\r\n            }\r\n        }\r\n    }\r\n    \r\n    void UpdateArmToTarget()\r\n    {\r\n        if (targetObject == null || endEffector == null) return;\r\n        \r\n        if (useIK)\r\n        {\r\n            // Simple inverse kinematics for reaching target\r\n            // This is a simplified implementation  real IK would be more complex\r\n            Vector3 directionToTarget = (targetObject.position  baseJoint.position).normalized;\r\n            \r\n            // Set the first joint to point toward the target\r\n            if (joints.Length > 0 && joints[0] != null)\r\n            {\r\n                joints[0].transform.LookAt(targetObject);\r\n                joints[0].transform.Rotate(90, 0, 0); // Adjust for joint orientation\r\n            }\r\n            \r\n            // Additional IK calculations would go here for more complex arms\r\n        }\r\n        else\r\n        {\r\n            // Move arm closer to target position (simplified)\r\n            Vector3 directionToTarget = (targetObject.position  endEffector.position).normalized;\r\n            float distance = Vector3.Distance(endEffector.position, targetObject.position);\r\n            \r\n            if (distance > 0.1f) // Threshold for reaching the target\r\n            {\r\n                // Adjust joint angles to move closer to target\r\n                // This is a simplified approach  real implementation would use proper IK algorithms\r\n                for (int i = 0; i < joints.Length; i++)\r\n                {\r\n                    if (joints[i] != null)\r\n                    {\r\n                        // Rotate joint slightly toward target position\r\n                        float adjustment = Mathf.Sign(Vector3.Dot(directionToTarget, joints[i].transform.forward)) * 0.5f;\r\n                        SetJointAngle(i, currentJointAngles[i] + adjustment);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    public void HighlightArm()\r\n    {\r\n        if (selectedMaterial != null)\r\n        {\r\n            foreach (Renderer renderer in armRenderers)\r\n            {\r\n                if (renderer != null)\r\n                {\r\n                    renderer.material = selectedMaterial;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    public void ResetArmVisuals()\r\n    {\r\n        if (defaultMaterial != null)\r\n        {\r\n            foreach (Renderer renderer in armRenderers)\r\n            {\r\n                if (renderer != null)\r\n                {\r\n                    renderer.material = defaultMaterial;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Animation coroutine for smooth movement\r\n    public IEnumerator AnimateToJointConfiguration(float[] targetAngles, float duration)\r\n    {\r\n        isAnimating = true;\r\n        \r\n        float[] startAngles = new float[currentJointAngles.Length];\r\n        for (int i = 0; i < currentJointAngles.Length; i++)\r\n        {\r\n            startAngles[i] = currentJointAngles[i];\r\n        }\r\n        \r\n        float elapsed = 0f;\r\n        while (elapsed < duration)\r\n        {\r\n            elapsed += Time.deltaTime;\r\n            float progress = Mathf.Clamp01(elapsed / duration);\r\n            \r\n            for (int i = 0; i < currentJointAngles.Length; i++)\r\n            {\r\n                currentJointAngles[i] = Mathf.Lerp(startAngles[i], targetAngles[i], progress);\r\n            }\r\n            \r\n            yield return null;\r\n        }\r\n        \r\n        // Ensure final position is reached\r\n        for (int i = 0; i < currentJointAngles.Length; i++)\r\n        {\r\n            currentJointAngles[i] = targetAngles[i];\r\n        }\r\n        \r\n        isAnimating = false;\r\n    }\r\n    \r\n    // Gizmos for debugging joint positions\r\n    void OnDrawGizmos()\r\n    {\r\n        if (joints != null)\r\n        {\r\n            for (int i = 0; i < joints.Length; i++)\r\n            {\r\n                if (joints[i] != null)\r\n                {\r\n                    Gizmos.color = Color.yellow;\r\n                    Gizmos.DrawSphere(joints[i].position, 0.05f);\r\n                    \r\n                    // Draw line to next joint\r\n                    if (i < joints.Length  1 && joints[i+1] != null)\r\n                    {\r\n                        Gizmos.color = Color.cyan;\r\n                        Gizmos.DrawLine(joints[i].position, joints[i+1].position);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // Draw end effector\r\n            if (endEffector != null)\r\n            {\r\n                Gizmos.color = Color.red;\r\n                Gizmos.DrawSphere(endEffector.position, 0.05f);\r\n            }\r\n            \r\n            // Draw target if tracking\r\n            if (trackTarget && targetObject != null)\r\n            {\r\n                Gizmos.color = Color.green;\r\n                Gizmos.DrawSphere(targetObject.position, 0.1f);\r\n                Gizmos.DrawLine(endEffector != null ? endEffector.position : Vector3.zero, targetObject.position);\r\n            }\r\n        }\r\n    }\r\n}-\n'})}),"\n",(0,i.jsx)(r.h3,{id:"unity-scene-setup-for-robotics-visualization",children:"Unity Scene Setup for Robotics Visualization"}),"\n",(0,i.jsx)(r.p,{children:"The scene setup would include:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Environment Setup"}),": Create a realistic environment with proper lighting"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Robot Model"}),": Import or create robot models with proper physical properties"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Camera System"}),": Set up cameras for different viewing perspectives"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Lighting"}),": Configure HDRP lighting for realistic appearance"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"PostProcessing"}),": Apply postprocessing effects for enhanced visual quality"]}),"\n"]}),"\n",(0,i.jsxs)(r.h3,{id:"hri-dashboard-example-hridashboardcs",children:["HRI Dashboard Example (",(0,i.jsx)(r.code,{children:"HRIDashboard.cs"}),")"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'using UnityEngine;\r\nusing UnityEngine.UI;\r\nusing TMPro;\r\nusing System.Collections.Generic;\r\n\r\npublic class HRIDashboard : MonoBehaviour\r\n{-\r\n    [Header("Dashboard Elements")]\r\n    public TextMeshProUGUI robotNameText;\r\n    public TextMeshProUGUI statusText;\r\n    public TextMeshProUGUI batteryText;\r\n    public TextMeshProUGUI taskText;\r\n    public Slider batterySlider;\r\n    public Image statusIndicator;\r\n    public Button emergencyStopButton;\r\n    \r\n    [Header("Task Progress")]\r\n    public Slider taskProgressSlider;\r\n    public TextMeshProUGUI taskProgressText;\r\n    \r\n    [Header("Robot Control")]\r\n    public Button startTaskButton;\r\n    public Button pauseTaskButton;\r\n    public Button resetButton;\r\n    \r\n    [Header("Data Visualization")]\r\n    public List<GameObject> sensorVisualizations;\r\n    \r\n    private string robotName = "Robotic Arm";\r\n    private float batteryLevel = 100f;\r\n    private string currentStatus = "Ready";\r\n    private string currentTask = "Idle";\r\n    private float taskProgress = 0f;\r\n    private Color normalStatusColor = Color.green;\r\n    private Color warningStatusColor = Color.yellow;\r\n    private Color errorStatusColor = Color.red;\r\n    \r\n    void Start()\r\n    {\r\n        InitializeDashboard();\r\n    }\r\n    \r\n    void InitializeDashboard()\r\n    {\r\n        robotNameText.text = robotName;\r\n        UpdateStatus(currentStatus);\r\n        UpdateBatteryLevel(batteryLevel);\r\n        UpdateTask(currentTask);\r\n        \r\n        // Setup button listeners\r\n        if (emergencyStopButton != null)\r\n            emergencyStopButton.onClick.AddListener(EmergencyStop);\r\n        \r\n        if (startTaskButton != null)\r\n            startTaskButton.onClick.AddListener(StartTask);\r\n        \r\n        if (pauseTaskButton != null)\r\n            pauseTaskButton.onClick.AddListener(PauseTask);\r\n        \r\n        if (resetButton != null)\r\n            resetButton.onClick.AddListener(ResetRobot);\r\n    }\r\n    \r\n    public void UpdateStatus(string status)\r\n    {\r\n        currentStatus = status;\r\n        statusText.text = $"Status: {status}";\r\n        \r\n        // Update status indicator color based on status\r\n        if (statusIndicator != null)\r\n        {\r\n            switch (status.ToLower())\r\n            {\r\n                case "ready":\r\n                case "idle":\r\n                    statusIndicator.color = normalStatusColor;\r\n                    break;\r\n                case "warning":\r\n                    statusIndicator.color = warningStatusColor;\r\n                    break;\r\n                case "error":\r\n                case "emergency":\r\n                    statusIndicator.color = errorStatusColor;\r\n                    break;\r\n                default:\r\n                    statusIndicator.color = normalStatusColor;\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    public void UpdateBatteryLevel(float level)\r\n    {\r\n        batteryLevel = Mathf.Clamp(level, 0f, 100f);\r\n        batteryText.text = $"Battery: {batteryLevel:F1}%";\r\n        \r\n        if (batterySlider != null)\r\n        {\r\n            batterySlider.value = batteryLevel;\r\n        }\r\n        \r\n        // Change battery color based on level\r\n        if (batteryText != null)\r\n        {\r\n            if (batteryLevel < 20f)\r\n            {\r\n                batteryText.color = Color.red;\r\n            }\r\n            else if (batteryLevel < 50f)\r\n            {\r\n                batteryText.color = Color.yellow;\r\n            }\r\n            else\r\n            {\r\n                batteryText.color = Color.green;\r\n            }\r\n        }\r\n    }\r\n    \r\n    public void UpdateTask(string taskName)\r\n    {\r\n        currentTask = taskName;\r\n        taskText.text = $"Task: {taskName}";\r\n    }\r\n    \r\n    public void UpdateTaskProgress(float progress)\r\n    {\r\n        taskProgress = Mathf.Clamp01(progress);\r\n        \r\n        if (taskProgressSlider != null)\r\n        {\r\n            taskProgressSlider.value = taskProgress;\r\n        }\r\n        \r\n        if (taskProgressText != null)\r\n        {\r\n            taskProgressText.text = $"Progress: {(taskProgress * 100):F1}%";\r\n        }\r\n    }\r\n    \r\n    public void EmergencyStop()\r\n    {\r\n        Debug.Log("Emergency Stop Activated!");\r\n        UpdateStatus("Emergency Stop");\r\n        \r\n        // In a real system, this would send an emergency stop command to the robot\r\n        // For now, we\'ll just log the event\r\n    }\r\n    \r\n    public void StartTask()\r\n    {\r\n        Debug.Log("Task Started!");\r\n        UpdateStatus("Working");\r\n        UpdateTaskProgress(0f);\r\n    }\r\n    \r\n    public void PauseTask()\r\n    {\r\n        Debug.Log("Task Paused!");\r\n        UpdateStatus("Paused");\r\n    }\r\n    \r\n    public void ResetRobot()\r\n    {\r\n        Debug.Log("Robot Reset!");\r\n        UpdateStatus("Ready");\r\n        UpdateTask("Idle");\r\n        UpdateTaskProgress(0f);\r\n        UpdateBatteryLevel(100f);\r\n    }\r\n    \r\n    // Visualization methods for sensor data\r\n    public void ShowSensorData(string sensorName, float value, float minRange, float maxRange)\r\n    {\r\n        // In a real system, this would visualize sensor data on the dashboard\r\n        Debug.Log($"Sensor {sensorName}: {value:F2} (Range: {minRange}  {maxRange})");\r\n    }\r\n    \r\n    public void ShowSensorData(string sensorName, Vector3 position)\r\n    {\r\n        // Visualize position data\r\n        Debug.Log($"Position Sensor {sensorName}: ({position.x:F2}, {position.y:F2}, {position.z:F2})");\r\n    }\r\n    \r\n    void Update()\r\n    {\r\n        // Simulate battery drain over time\r\n        if (currentStatus == "Working")\r\n        {\r\n            UpdateBatteryLevel(batteryLevel  0.01f); // Drain 0.01% per frame when working\r\n            \r\n            // Simulate task progress\r\n            UpdateTaskProgress(taskProgress + 0.001f);\r\n        }\r\n    }\r\n}-\n'})}),"\n",(0,i.jsx)(r.h2,{id:"miniproject",children:"Miniproject"}),"\n",(0,i.jsx)(r.p,{children:"Create a complete Unitybased visualization system for a mobile robot that includes:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsx)(r.li,{children:"A photorealistic environment using HDRP"}),"\n",(0,i.jsx)(r.li,{children:"A robot model with accurate kinematics and dynamics"}),"\n",(0,i.jsx)(r.li,{children:"An HRI interface with status monitoring and control"}),"\n",(0,i.jsx)(r.li,{children:"Integration with sensor data visualization (LiDAR, camera, IMU)"}),"\n",(0,i.jsx)(r.li,{children:"VR/AR support for immersive interaction"}),"\n",(0,i.jsx)(r.li,{children:"Realtime performance metrics display"}),"\n",(0,i.jsx)(r.li,{children:"Emergency stop and safety interlocks"}),"\n",(0,i.jsx)(r.li,{children:"Recording and playback functionality"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Your system should include:\r\nComplete Unity scene with HDRP lighting\r\nRobot controller with realistic movement\r\nHRI dashboard showing robot status and controls\r\nSensor data visualization\r\nPerformance optimization techniques\r\nSafety features implementation"}),"\n",(0,i.jsx)(r.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(r.p,{children:"This chapter covered Unity HDRP for highfidelity visualization and HumanRobot Interaction:"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"HDRP Setup"}),": Configuring Unity's High Definition Render Pipeline for photorealistic rendering\r\n",(0,i.jsx)(r.strong,{children:"Robot Visualization"}),": Creating detailed 3D robot models with accurate kinematics\r\n",(0,i.jsx)(r.strong,{children:"HRI Interfaces"}),": Designing intuitive user interfaces for robot control and monitoring\r\n",(0,i.jsx)(r.strong,{children:"UnityROS Integration"}),": Connecting Unity with ROS 2 for bidirectional communication\r\n",(0,i.jsx)(r.strong,{children:"Performance Optimization"}),": Techniques for maintaining realtime performance with complex scenes\r\n",(0,i.jsx)(r.strong,{children:"Safety Considerations"}),": Implementing emergency stops and safety interlocks in HRI systems"]}),"\n",(0,i.jsx)(r.p,{children:"Unity HDRP provides powerful tools for creating visually impressive simulation environments that can significantly enhance the development and testing of robotic systems."})]})}function g(n={}){const{wrapper:r}={...(0,o.R)(),...n.components};return r?(0,i.jsx)(r,{...n,children:(0,i.jsx)(u,{...n})}):u(n)}}}]);