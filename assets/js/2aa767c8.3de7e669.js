"use strict";(globalThis.webpackChunkai_native_robotics_textbook=globalThis.webpackChunkai_native_robotics_textbook||[]).push([[7292],{3507:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"module-3-ai-robot-brain/ch14-bipedal-locomotion-balance","title":"ch14-bipedal-locomotion-balance","description":"-----","source":"@site/docs/module-3-ai-robot-brain/ch14-bipedal-locomotion-balance.md","sourceDirName":"module-3-ai-robot-brain","slug":"/module-3-ai-robot-brain/ch14-bipedal-locomotion-balance","permalink":"/physical-ai-textbook-2025/docs/module-3-ai-robot-brain/ch14-bipedal-locomotion-balance","draft":false,"unlisted":false,"editUrl":"https://github.com/Tayyaba10/physical-ai-textbook-2025/edit/main/docs/module-3-ai-robot-brain/ch14-bipedal-locomotion-balance.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"ch13-isaac-ros-accelerated-vslam","permalink":"/physical-ai-textbook-2025/docs/module-3-ai-robot-brain/ch13-isaac-ros-accelerated-vslam"},"next":{"title":"ch15-reinforcement-learning-sim2real","permalink":"/physical-ai-textbook-2025/docs/module-3-ai-robot-brain/ch15-reinforcement-learning-sim2real"}}');var o=n(4848),i=n(8453),l=n(7242);const s={},a=void 0,c={},p=[{value:"title: Ch14  Bipedal Locomotion &amp; Balance Control\r\nmodule: 3\r\nchapter: 14\r\nsidebar_label: Ch14: Bipedal Locomotion &amp; Balance Control\r\ndescription: Implementing bipedal locomotion and balance control using Isaac Sim and advanced control systems\r\ntags: [bipedal, locomotion, balance, control, humanoid, robotics, isaacsim, MPC]\r\ndifficulty: advanced\r\nestimated_duration: 150",id:"title-ch14--bipedal-locomotion--balance-controlmodule-3chapter-14sidebar_label-ch14-bipedal-locomotion--balance-controldescription-implementing-bipedal-locomotion-and-balance-control-using-isaac-sim-and-advanced-control-systemstags-bipedal-locomotion-balance-control-humanoid-robotics-isaacsim-mpcdifficulty-advancedestimated_duration-150",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Theory",id:"theory",level:2},{value:"Bipedal Locomotion Fundamentals",id:"bipedal-locomotion-fundamentals",level:3},{value:"Balance Control Approaches",id:"balance-control-approaches",level:3},{value:"Gait Generation and Control",id:"gait-generation-and-control",level:3},{value:"Model Predictive Control (MPC) for Walking",id:"model-predictive-control-mpc-for-walking",level:3},{value:"StepbyStep Labs",id:"stepbystep-labs",level:2},{value:"Lab 1: Setting up a Bipedal Robot Model in Isaac Sim",id:"lab-1-setting-up-a-bipedal-robot-model-in-isaac-sim",level:3},{value:"Lab 2: Implementing Inverted Pendulum Balance Controller",id:"lab-2-implementing-inverted-pendulum-balance-controller",level:3},{value:"Lab 3: Model Predictive Control for Walking",id:"lab-3-model-predictive-control-for-walking",level:3},{value:"Runnable Code Example",id:"runnable-code-example",level:2},{value:"Miniproject",id:"miniproject",level:2},{value:"Summary",id:"summary",level:2}];function f(r){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...r.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h2,{id:"title-ch14--bipedal-locomotion--balance-controlmodule-3chapter-14sidebar_label-ch14-bipedal-locomotion--balance-controldescription-implementing-bipedal-locomotion-and-balance-control-using-isaac-sim-and-advanced-control-systemstags-bipedal-locomotion-balance-control-humanoid-robotics-isaacsim-mpcdifficulty-advancedestimated_duration-150",children:"title: Ch14  Bipedal Locomotion & Balance Control\r\nmodule: 3\r\nchapter: 14\r\nsidebar_label: Ch14: Bipedal Locomotion & Balance Control\r\ndescription: Implementing bipedal locomotion and balance control using Isaac Sim and advanced control systems\r\ntags: [bipedal, locomotion, balance, control, humanoid, robotics, isaacsim, MPC]\r\ndifficulty: advanced\r\nestimated_duration: 150"}),"\n","\n",(0,o.jsx)(e.h1,{id:"bipedal-locomotion--balance-control",children:"Bipedal Locomotion & Balance Control"}),"\n",(0,o.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,o.jsx)(e.p,{children:"Understand the principles of bipedal locomotion and balance control\r\nImplement advanced control strategies for humanoid robots\r\nCreate dynamic walking gaits using model predictive control (MPC)\r\nSimulate bipedal robots in Isaac Sim with realistic physics\r\nDesign and tune balance controllers for perturbation recovery\r\nImplement footstep planning and trajectory generation\r\nEvaluate stability and performance of bipedal locomotion systems"}),"\n",(0,o.jsx)(e.h2,{id:"theory",children:"Theory"}),"\n",(0,o.jsx)(e.h3,{id:"bipedal-locomotion-fundamentals",children:"Bipedal Locomotion Fundamentals"}),"\n",(0,o.jsx)(e.p,{children:"Bipedal locomotion presents unique challenges compared to wheeled or quadrupedal locomotion. The system must maintain balance with only two points of contact with the ground while in motion."}),"\n",(0,o.jsx)(l.A,{chart:"\ngraph TD;\n  A[Bipedal Locomotion] > B[Balance Control];\n  A > C[Locomotion Gait];\n  A > D[Stability Analysis];\n  \n  B > E[Center of Mass Control];\n  B > F[Zero Moment Point];\n  B > G[Capture Point];\n  \n  C > H[Walk Cycle];\n  C > I[Step Planning];\n  C > J[Trajectory Generation];\n  \n  D > K[Stability Margins];\n  D > L[Robustness Analysis];\n  D > M[Recovery Strategies];\n  \n  style A fill:#4CAF50,stroke:#388E3C,color:#fff;\n  style B fill:#2196F3,stroke:#0D47A1,color:#fff;\n  style C fill:#FF9800,stroke:#E65100,color:#fff;\n"}),"\n",(0,o.jsx)(e.h3,{id:"balance-control-approaches",children:"Balance Control Approaches"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Zero Moment Point (ZMP)"}),": A critical concept in bipedal robotics representing the point on the ground where the net moment of the ground reaction force is zero. Maintaining ZMP within the support polygon is essential for stability."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Capture Point (CP)"}),": The point where a biped can come to rest given its current velocity. The capture point is used to design stable walking patterns."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Linear Inverted Pendulum Model (LIPM)"}),": Simplifies the robot to a point mass with constant height, allowing for analytical solutions to balance control."]}),"\n",(0,o.jsx)(e.h3,{id:"gait-generation-and-control",children:"Gait Generation and Control"}),"\n",(0,o.jsx)(e.p,{children:"Bipedal gaits involve complex coordination of joints and careful foot placement. Key phases include:"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Single Support"}),": One foot in contact with ground\r\n",(0,o.jsx)(e.strong,{children:"Double Support"}),": Both feet in contact during step transitions\r\n",(0,o.jsx)(e.strong,{children:"Swing Phase"}),": Nonstance leg swinging forward"]}),"\n",(0,o.jsx)(e.h3,{id:"model-predictive-control-mpc-for-walking",children:"Model Predictive Control (MPC) for Walking"}),"\n",(0,o.jsx)(e.p,{children:"MPC is particularly wellsuited for bipedal walking due to its ability to handle constraints and predict future states. The controller optimizes a cost function over a prediction horizon while respecting system dynamics and constraints."}),"\n",(0,o.jsx)(e.h2,{id:"stepbystep-labs",children:"StepbyStep Labs"}),"\n",(0,o.jsx)(e.h3,{id:"lab-1-setting-up-a-bipedal-robot-model-in-isaac-sim",children:"Lab 1: Setting up a Bipedal Robot Model in Isaac Sim"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Create a simplified bipedal robot URDF"})," (",(0,o.jsx)(e.code,{children:"bipedal_robot.urdf"}),"):"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\r\n<robot name="simple_biped">\r\n  <material name="blue">\r\n    <color rgba="0.0 0.0 1.0 1.0"/>\r\n  </material>\r\n  <material name="red">\r\n    <color rgba="1.0 0.0 0.0 1.0"/>\r\n  </material>\r\n  <material name="white">\r\n    <color rgba="1.0 1.0 1.0 1.0"/>\r\n  </material>\r\n\r\n  <! Torso >\r\n  <link name="torso">\r\n    <inertial>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <mass value="10.0"/>\r\n      <inertia ixx="0.5" ixy="0.0" ixz="0.0" iyy="0.5" iyz="0.0" izz="0.3"/>\r\n    </inertial>\r\n    <visual>\r\n      <origin xyz="0 0 0.5" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.3 0.3 1.0"/>\r\n      </geometry>\r\n      <material name="white"/>\r\n    </visual>\r\n    <collision>\r\n      <origin xyz="0 0 0.5" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.3 0.3 1.0"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  <! Head >\r\n  <link name="head">\r\n    <inertial>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <mass value="2.0"/>\r\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>\r\n    </inertial>\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <sphere radius="0.15"/>\r\n      </geometry>\r\n      <material name="red"/>\r\n    </visual>\r\n    <collision>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <sphere radius="0.15"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  <joint name="torso_head" type="fixed">\r\n    <parent link="torso"/>\r\n    <child link="head"/>\r\n    <origin xyz="0 0 1.0" rpy="0 0 0"/>\r\n  </joint>\r\n\r\n  <! Left Hip >\r\n  <link name="left_hip">\r\n    <inertial>\r\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\r\n      <mass value="2.0"/>\r\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.02"/>\r\n    </inertial>\r\n    <visual>\r\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.05" length="0.3"/>\r\n      </geometry>\r\n      <material name="blue"/>\r\n    </visual>\r\n    <collision>\r\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.05" length="0.3"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  <joint name="left_hip_joint" type="revolute">\r\n    <parent link="torso"/>\r\n    <child link="left_hip"/>\r\n    <origin xyz="0 0.15 0" rpy="0 0 0"/>\r\n    <axis xyz="1 0 0"/>\r\n    <limit lower="1.57" upper="1.57" effort="100" velocity="1.0"/>\r\n  </joint>\r\n\r\n  <! Left Upper Leg >\r\n  <link name="left_upper_leg">\r\n    <inertial>\r\n      <origin xyz="0 0 0.2" rpy="0 0 0"/>\r\n      <mass value="3.0"/>\r\n      <inertia ixx="0.2" ixy="0.0" ixz="0.0" iyy="0.2" iyz="0.0" izz="0.03"/>\r\n    </inertial>\r\n    <visual>\r\n      <origin xyz="0 0 0.2" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.06" length="0.4"/>\r\n      </geometry>\r\n      <material name="blue"/>\r\n    </visual>\r\n    <collision>\r\n      <origin xyz="0 0 0.2" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.06" length="0.4"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  <joint name="left_knee_joint" type="revolute">\r\n    <parent link="left_hip"/>\r\n    <child link="left_upper_leg"/>\r\n    <origin xyz="0 0 0.3" rpy="0 0 0"/>\r\n    <axis xyz="1 0 0"/>\r\n    <limit lower="0" upper="2.35" effort="100" velocity="1.0"/>\r\n  </joint>\r\n\r\n  <! Left Lower Leg >\r\n  <link name="left_lower_leg">\r\n    <inertial>\r\n      <origin xyz="0 0 0.2" rpy="0 0 0"/>\r\n      <mass value="2.5"/>\r\n      <inertia ixx="0.15" ixy="0.0" ixz="0.0" iyy="0.15" iyz="0.0" izz="0.02"/>\r\n    </inertial>\r\n    <visual>\r\n      <origin xyz="0 0 0.2" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.05" length="0.4"/>\r\n      </geometry>\r\n      <material name="blue"/>\r\n    </visual>\r\n    <collision>\r\n      <origin xyz="0 0 0.2" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.05" length="0.4"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  <joint name="left_ankle_joint" type="revolute">\r\n    <parent link="left_upper_leg"/>\r\n    <child link="left_lower_leg"/>\r\n    <origin xyz="0 0 0.4" rpy="0 0 0"/>\r\n    <axis xyz="1 0 0"/>\r\n    <limit lower="0.78" upper="0.78" effort="50" velocity="1.0"/>\r\n  </joint>\r\n\r\n  <! Left Foot >\r\n  <link name="left_foot">\r\n    <inertial>\r\n      <origin xyz="0.05 0 0.025" rpy="0 0 0"/>\r\n      <mass value="1.0"/>\r\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.005"/>\r\n    </inertial>\r\n    <visual>\r\n      <origin xyz="0.05 0 0.025" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.2 0.1 0.05"/>\r\n      </geometry>\r\n      <material name="red"/>\r\n    </visual>\r\n    <collision>\r\n      <origin xyz="0.05 0 0.025" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.2 0.1 0.05"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  <joint name="left_foot_joint" type="fixed">\r\n    <parent link="left_lower_leg"/>\r\n    <child link="left_foot"/>\r\n    <origin xyz="0 0 0.4" rpy="0 0 0"/>\r\n  </joint>\r\n\r\n  <! Right Leg (mirror of left) >\r\n  <link name="right_hip">\r\n    <inertial>\r\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\r\n      <mass value="2.0"/>\r\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.02"/>\r\n    </inertial>\r\n    <visual>\r\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.05" length="0.3"/>\r\n      </geometry>\r\n      <material name="blue"/>\r\n    </visual>\r\n    <collision>\r\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.05" length="0.3"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  <joint name="right_hip_joint" type="revolute">\r\n    <parent link="torso"/>\r\n    <child link="right_hip"/>\r\n    <origin xyz="0 0.15 0" rpy="0 0 0"/>\r\n    <axis xyz="1 0 0"/>\r\n    <limit lower="1.57" upper="1.57" effort="100" velocity="1.0"/>\r\n  </joint>\r\n\r\n  <link name="right_upper_leg">\r\n    <inertial>\r\n      <origin xyz="0 0 0.2" rpy="0 0 0"/>\r\n      <mass value="3.0"/>\r\n      <inertia ixx="0.2" ixy="0.0" ixz="0.0" iyy="0.2" iyz="0.0" izz="0.03"/>\r\n    </inertial>\r\n    <visual>\r\n      <origin xyz="0 0 0.2" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.06" length="0.4"/>\r\n      </geometry>\r\n      <material name="blue"/>\r\n    </visual>\r\n    <collision>\r\n      <origin xyz="0 0 0.2" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.06" length="0.4"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  <joint name="right_knee_joint" type="revolute">\r\n    <parent link="right_hip"/>\r\n    <child link="right_upper_leg"/>\r\n    <origin xyz="0 0 0.3" rpy="0 0 0"/>\r\n    <axis xyz="1 0 0"/>\r\n    <limit lower="0" upper="2.35" effort="100" velocity="1.0"/>\r\n  </joint>\r\n\r\n  <link name="right_lower_leg">\r\n    <inertial>\r\n      <origin xyz="0 0 0.2" rpy="0 0 0"/>\r\n      <mass value="2.5"/>\r\n      <inertia ixx="0.15" ixy="0.0" ixz="0.0" iyy="0.15" iyz="0.0" izz="0.02"/>\r\n    </inertial>\r\n    <visual>\r\n      <origin xyz="0 0 0.2" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.05" length="0.4"/>\r\n      </geometry>\r\n      <material name="blue"/>\r\n    </visual>\r\n    <collision>\r\n      <origin xyz="0 0 0.2" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.05" length="0.4"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  <joint name="right_ankle_joint" type="revolute">\r\n    <parent link="right_upper_leg"/>\r\n    <child link="right_lower_leg"/>\r\n    <origin xyz="0 0 0.4" rpy="0 0 0"/>\r\n    <axis xyz="1 0 0"/>\r\n    <limit lower="0.78" upper="0.78" effort="50" velocity="1.0"/>\r\n  </joint>\r\n\r\n  <link name="right_foot">\r\n    <inertial>\r\n      <origin xyz="0.05 0 0.025" rpy="0 0 0"/>\r\n      <mass value="1.0"/>\r\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.005"/>\r\n    </inertial>\r\n    <visual>\r\n      <origin xyz="0.05 0 0.025" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.2 0.1 0.05"/>\r\n      </geometry>\r\n      <material name="red"/>\r\n    </visual>\r\n    <collision>\r\n      <origin xyz="0.05 0 0.025" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.2 0.1 0.05"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  <joint name="right_foot_joint" type="fixed">\r\n    <parent link="right_lower_leg"/>\r\n    <child link="right_foot"/>\r\n    <origin xyz="0 0 0.4" rpy="0 0 0"/>\r\n  </joint>\r\n\r\n  <! Arms for additional balance control >\r\n  <link name="left_upper_arm">\r\n    <inertial>\r\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\r\n      <mass value="1.5"/>\r\n      <inertia ixx="0.05" ixy="0.0" ixz="0.0" iyy="0.05" iyz="0.0" izz="0.01"/>\r\n    </inertial>\r\n    <visual>\r\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.04" length="0.3"/>\r\n      </geometry>\r\n      <material name="blue"/>\r\n    </visual>\r\n    <collision>\r\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.04" length="0.3"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  <joint name="left_shoulder_joint" type="revolute">\r\n    <parent link="torso"/>\r\n    <child link="left_upper_arm"/>\r\n    <origin xyz="0.1 0.15 0.7" rpy="0 0 0"/>\r\n    <axis xyz="0 1 0"/>\r\n    <limit lower="1.57" upper="1.57" effort="50" velocity="1.0"/>\r\n  </joint>\r\n\r\n  <link name="right_upper_arm">\r\n    <inertial>\r\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\r\n      <mass value="1.5"/>\r\n      <inertia ixx="0.05" ixy="0.0" ixz="0.0" iyy="0.05" iyz="0.0" izz="0.01"/>\r\n    </inertial>\r\n    <visual>\r\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.04" length="0.3"/>\r\n      </geometry>\r\n      <material name="blue"/>\r\n    </visual>\r\n    <collision>\r\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.04" length="0.3"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  <joint name="right_shoulder_joint" type="revolute">\r\n    <parent link="torso"/>\r\n    <child link="right_upper_arm"/>\r\n    <origin xyz="0.1 0.15 0.7" rpy="0 0 0"/>\r\n    <axis xyz="0 1 0"/>\r\n    <limit lower="1.57" upper="1.57" effort="50" velocity="1.0"/>\r\n  </joint>\r\n</robot>\n'})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Load the robot into Isaac Sim"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# biped_loader.py\r\nimport omni\r\nfrom pxr import Gf, UsdGeom\r\nfrom omni.isaac.core import World\r\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\r\nfrom omni.isaac.core.utils.prims import get_prim_at_path\r\nfrom omni.isaac.core.utils.viewports import set_camera_view\r\nimport numpy as np\r\n\r\ndef load_biped_robot():\r\n    """Load the biped robot into Isaac Sim"""\r\n    # Add the robot model to the stage\r\n    robot_path = "/World/BipedRobot"\r\n    # In practice, you would load the URDF using Isaac Sim\'s URDF import functionality\r\n    # For this example, we\'ll create a simplified representation\r\n    \r\n    # Create the main body\r\n    from omni.isaac.core.utils.prims import create_prim\r\n    create_prim(\r\n        "/World/BipedRobot/Torso",\r\n        "Cuboid",\r\n        position=(0, 0, 1.0),\r\n        attributes={"size": 0.3}\r\n    )\r\n    \r\n    # Set up physics\r\n    from omni.physx.scripts import physicsUtils\r\n    stage = omni.usd.get_context().get_stage()\r\n    default_prim = stage.GetDefaultPrim()\r\n    \r\n    # Add ground plane\r\n    create_prim(\r\n        "/World/GroundPlane",\r\n        "Plane",\r\n        position=(0, 0, 0),\r\n        attributes={"size": 10.0}\r\n    )\r\n    \r\n    # Set camera view\r\n    set_camera_view(eye=(5, 5, 3), target=(0, 0, 1))\r\n    \r\n    print("Biped robot loaded into Isaac Sim")\r\n\r\n# Run when in Isaac Sim environment\r\nif __name__ == "__main__":\r\n    load_biped_robot()\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"lab-2-implementing-inverted-pendulum-balance-controller",children:"Lab 2: Implementing Inverted Pendulum Balance Controller"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Create a Linear Inverted Pendulum Model (LIPM) controller"})," (",(0,o.jsx)(e.code,{children:"lipm_controller.py"}),"):","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n\r\nimport numpy as np\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState, Imu\r\nfrom geometry_msgs.msg import Point, Vector3\r\nfrom std_msgs.msg import Float64MultiArray\r\nimport math\r\n\r\nclass LIPMController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'lipm_controller\')\r\n        \r\n        # LIPM parameters\r\n        self.height = 0.84  # Center of mass height (meters)\r\n        self.gravity = 9.81  # Gravity (m/s\xb2)\r\n        self.omega = math.sqrt(self.gravity / self.height)  # Natural frequency\r\n        \r\n        # Robot state\r\n        self.com_position = np.array([0.0, 0.0, self.height])  # Center of mass position\r\n        self.com_velocity = np.array([0.0, 0.0, 0.0])          # Center of mass velocity\r\n        self.support_foot = "left"  # Current support foot\r\n        self.step_frequency = 0.5  # Steps per second\r\n        \r\n        # Walking parameters\r\n        self.step_length = 0.3    # Forward step length (m)\r\n        self.step_width = 0.2     # Lateral step width (m)\r\n        self.nominal_com_height = self.height\r\n        \r\n        # PID controllers for balance\r\n        self.kp_com_x = 8.0\r\n        self.kd_com_x = 2.0\r\n        self.kp_com_y = 8.0\r\n        self.kd_com_y = 2.0\r\n        \r\n        # Subscribers\r\n        self.joint_state_sub = self.create_subscription(\r\n            JointState, \'/joint_states\', self.joint_state_callback, 10)\r\n        self.imu_sub = self.create_subscription(\r\n            Imu, \'/imu\', self.imu_callback, 10)\r\n        \r\n        # Publishers\r\n        self.com_pub = self.create_publisher(\r\n            Point, \'/center_of_mass\', 10)\r\n        self.zmp_pub = self.create_publisher(\r\n            Point, \'/zmp\', 10)\r\n        self.footstep_pub = self.create_publisher(\r\n            Float64MultiArray, \'/desired_footstep\', 10)\r\n        self.com_ref_pub = self.create_publisher(\r\n            Point, \'/com_reference\', 10)\r\n        \r\n        # Timer for control loop\r\n        self.control_timer = self.create_timer(0.01, self.balance_control_step)  # 100 Hz\r\n        \r\n        self.get_logger().info(\'LIPM Balance Controller initialized\')\r\n    \r\n    def joint_state_callback(self, msg):\r\n        """Update robot state from joint positions and velocities"""\r\n        # In a real implementation, this would compute CoM from joint angles\r\n        # For this example, we\'ll just track a moving CoM reference\r\n        pass\r\n    \r\n    def imu_callback(self, msg):\r\n        """Update CoM estimate from IMU data"""\r\n        # Integrate acceleration to estimate velocity and position\r\n        # This is a simplified approach  in reality you\'d use sensor fusion\r\n        linear_acc = msg.linear_acceleration\r\n        angular_vel = msg.angular_velocity\r\n        \r\n        # Update CoM velocity (would require more complex integration in practice)\r\n        dt = 0.01  # Assuming 100Hz control loop\r\n        self.com_velocity[0] += linear_acc.x * dt\r\n        self.com_velocity[1] += linear_acc.y * dt\r\n        self.com_velocity[2] += (linear_acc.z  self.gravity) * dt\r\n        \r\n        # Update CoM position\r\n        self.com_position += self.com_velocity * dt\r\n        \r\n        # Also update height from IMU if necessary\r\n        self.com_position[2] = max(self.com_position[2], self.nominal_com_height)\r\n    \r\n    def compute_zmp(self):\r\n        """Compute Zero Moment Point from CoM state"""\r\n        # ZMP_x = com_x  (h/g) * com_acc_x\r\n        # ZMP_y = com_y  (h/g) * com_acc_y\r\n        \r\n        # For this simplified version, we\'ll use the current CoM position\r\n        # adjusted by the inverted pendulum dynamics\r\n        zmp = Point()\r\n        zmp.x = self.com_position[0]  (self.height / self.gravity) * (self.com_velocity[0] * self.omega)\r\n        zmp.y = self.com_position[1]  (self.height / self.gravity) * (self.com_velocity[1] * self.omega)\r\n        zmp.z = 0.0  # ZMP is on ground plane\r\n        \r\n        return zmp\r\n    \r\n    def compute_capture_point(self):\r\n        """Compute Capture Point for balance recovery"""\r\n        # Capture Point = com_pos + com_vel/omega\r\n        cp_x = self.com_position[0] + self.com_velocity[0] / self.omega\r\n        cp_y = self.com_position[1] + self.com_velocity[1] / self.omega\r\n        \r\n        return np.array([cp_x, cp_y])\r\n    \r\n    def balance_control_step(self):\r\n        """Main balance control step"""\r\n        # Compute ZMP\r\n        zmp = self.compute_zmp()\r\n        self.zmp_pub.publish(zmp)\r\n        \r\n        # Publish CoM\r\n        com_msg = Point()\r\n        com_msg.x = float(self.com_position[0])\r\n        com_msg.y = float(self.com_position[1])\r\n        com_msg.z = float(self.com_position[2])\r\n        self.com_pub.publish(com_msg)\r\n        \r\n        # Compute reference CoM based on desired walking pattern\r\n        self.compute_com_reference()\r\n        \r\n        # Generate footsteps based on capture point\r\n        self.generate_footsteps()\r\n        \r\n        # Log current state\r\n        self.get_logger().debug(\r\n            f\'CoM: ({self.com_position[0]:.3f}, {self.com_position[1]:.3f}, {self.com_position[2]:.3f}), \'\r\n            f\'ZMP: ({zmp.x:.3f}, {zmp.y:.3f})\'\r\n        )\r\n    \r\n    def compute_com_reference(self):\r\n        """Compute desired CoM position for walking"""\r\n        # For walking, we want to oscillate CoM laterally and move forward\r\n        current_time = self.get_clock().now().nanoseconds / 1e9\r\n        \r\n        # Lateral oscillation for walking\r\n        lateral_oscillation = 0.05 * math.sin(2 * math.pi * self.step_frequency * current_time)\r\n        \r\n        # Forward progression\r\n        forward_progress = self.step_length * self.step_frequency * current_time\r\n        \r\n        # Update reference\r\n        self.com_ref = np.array([\r\n            forward_progress,  # Forward movement\r\n            lateral_oscillation if self.support_foot == "left" else lateral_oscillation,  # Lateral movement\r\n            self.nominal_com_height\r\n        ])\r\n        \r\n        # Publish reference\r\n        ref_msg = Point()\r\n        ref_msg.x = float(self.com_ref[0])\r\n        ref_msg.y = float(self.com_ref[1])\r\n        ref_msg.z = float(self.com_ref[2])\r\n        self.com_ref_pub.publish(ref_msg)\r\n    \r\n    def generate_footsteps(self):\r\n        """Generate desired footsteps based on capture point"""\r\n        capture_point = self.compute_capture_point()\r\n        \r\n        # Simple strategy: place foot near capture point with some offset\r\n        # to ensure ZMP remains in support polygon\r\n        if self.support_foot == "left":\r\n            # Right foot should go near capture point\r\n            target_pos = capture_point + np.array([0.1, self.step_width/2])\r\n            self.support_foot = "right"\r\n        else:\r\n            # Left foot should go near capture point\r\n            target_pos = capture_point + np.array([0.1, self.step_width/2])\r\n            self.support_foot = "left"\r\n        \r\n        # Publish desired footstep\r\n        footstep_msg = Float64MultiArray()\r\n        footstep_msg.data = [float(target_pos[0]), float(target_pos[1]), 0.0]\r\n        self.footstep_pub.publish(footstep_msg)\r\n        \r\n        self.get_logger().info(f\'Next footstep: ({target_pos[0]:.3f}, {target_pos[1]:.3f}) on {self.support_foot} foot\')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    controller = LIPMController()\r\n    \r\n    try:\r\n        rclpy.spin(controller)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        controller.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"lab-3-model-predictive-control-for-walking",children:"Lab 3: Model Predictive Control for Walking"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Create an MPC controller for bipedal walking"})," (",(0,o.jsx)(e.code,{children:"mpc_walking_controller.py"}),"):","\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n\r\nimport numpy as np\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState, Imu\r\nfrom geometry_msgs.msg import Point, Twist, PoseStamped\r\nfrom std_msgs.msg import Float64MultiArray, String\r\nimport math\r\nimport cvxpy as cp  # Convex optimization library for MPC\r\n\r\nclass MPCWalkingController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'mpc_walking_controller\')\r\n        \r\n        # MPC parameters\r\n        self.prediction_horizon = 20      # Number of steps to predict\r\n        self.control_horizon = 5          # Number of steps to optimize\r\n        self.dt = 0.1                     # Time step (seconds)\r\n        self.height = 0.84                # CoM height (m)\r\n        self.gravity = 9.81               # Gravity (m/s\xb2)\r\n        self.omega = math.sqrt(self.gravity / self.height)\r\n        \r\n        # Walking parameters\r\n        self.step_length = 0.3            # Step length (m)\r\n        self.step_width = 0.2             # Step width (m)\r\n        self.step_duration = 1.0          # Time per step (s)\r\n        \r\n        # Current state [x, y, xdot, ydot]\r\n        self.state = np.array([0.0, 0.0, 0.0, 0.0])\r\n        \r\n        # MPC weights\r\n        self.Q = np.diag([10.0, 10.0, 1.0, 1.0])  # State cost matrix\r\n        self.R = 0.1  # Control cost weight\r\n        self.Q_final = np.diag([50.0, 50.0, 5.0, 5.0])  # Terminal cost\r\n        \r\n        # Footstep plan\r\n        self.footstep_plan = []\r\n        self.current_step_idx = 0\r\n        self.support_foot = "left"\r\n        \r\n        # Subscribers\r\n        self.joint_state_sub = self.create_subscription(\r\n            JointState, \'/joint_states\', self.joint_state_callback, 10)\r\n        self.imu_sub = self.create_subscription(\r\n            Imu, \'/imu\', self.imu_callback, 10)\r\n        self.footstep_sub = self.create_subscription(\r\n            Float64MultiArray, \'/desired_footsteps\', self.footstep_callback, 10)\r\n        \r\n        # Publishers\r\n        self.zmp_pub = self.create_publisher(\r\n            Point, \'/zmp_reference\', 10)\r\n        self.com_traj_pub = self.create_publisher(\r\n            Float64MultiArray, \'/com_trajectory\', 10)\r\n        self.mpc_status_pub = self.create_publisher(\r\n            String, \'/mpc_status\', 10)\r\n        self.com_vel_pub = self.create_publisher(\r\n            Twist, \'/com_velocity\', 10)\r\n        \r\n        # Timer for control loop\r\n        self.control_timer = self.create_timer(0.05, self.mpc_control_step)  # 20 Hz\r\n        \r\n        self.get_logger().info(\'MPC Walking Controller initialized\')\r\n    \r\n    def joint_state_callback(self, msg):\r\n        """Update robot state from joint positions and velocities"""\r\n        # In a real implementation, this would compute CoM from joint angles\r\n        # This is a simplified approach\r\n        pass\r\n    \r\n    def imu_callback(self, msg):\r\n        """Update state estimate from IMU"""\r\n        # This would implement more sophisticated state estimation in practice\r\n        pass\r\n    \r\n    def footstep_callback(self, msg):\r\n        """Update footstep plan from planner"""\r\n        if len(msg.data) >= 2:\r\n            # Add new footstep to plan\r\n            new_step = (msg.data[0], msg.data[1], self.get_clock().now().seconds_nanoseconds()[0] + self.step_duration)\r\n            self.footstep_plan.append(new_step)\r\n            \r\n            # Keep only future footsteps\r\n            current_time = self.get_clock().now().seconds_nanoseconds()[0]\r\n            self.footstep_plan = [step for step in self.footstep_plan if step[2] > current_time]\r\n            \r\n            self.get_logger().info(f\'Updated footstep plan. {len(self.footstep_plan)} steps in plan.\')\r\n    \r\n    def setup_mpc_problem(self, x0, reference_trajectory):\r\n        """Set up the MPC optimization problem"""\r\n        N = self.prediction_horizon\r\n        \r\n        # State variables [x, y, xdot, ydot] for each time step\r\n        X = cp.Variable((4, N+1))\r\n        # Control variables [zmp_x, zmp_y] for each time step\r\n        U = cp.Variable((2, N))\r\n        \r\n        # System dynamics matrix for LIPM\r\n        A_cont = np.array([\r\n            [0, 0, 1, 0],\r\n            [0, 0, 0, 1],\r\n            [self.omega**2, 0, 0, 0],\r\n            [0, self.omega**2, 0, 0]\r\n        ])\r\n        \r\n        # Discretize system\r\n        I = np.eye(4)\r\n        A = I + self.dt * A_cont\r\n        B = self.dt * np.array([\r\n            [0, 0],\r\n            [0, 0],\r\n            [self.omega**2, 0],\r\n            [0, self.omega**2]\r\n        ])\r\n        \r\n        # Cost function\r\n        cost = 0\r\n        \r\n        # State and control penalties\r\n        for k in range(N):\r\n            # State cost (tracking reference)\r\n            state_error = X[:, k]  reference_trajectory[k]\r\n            cost += cp.quad_form(state_error, self.Q)\r\n            \r\n            # Control effort penalty\r\n            cost += self.R * cp.sum_squares(U[:, k])\r\n        \r\n        # Terminal cost\r\n        final_error = X[:, N]  reference_trajectory[N1]  # Use last reference\r\n        cost += cp.quad_form(final_error, self.Q_final)\r\n        \r\n        # Constraints\r\n        constraints = []\r\n        \r\n        # Initial state\r\n        constraints.append(X[:, 0] == x0)\r\n        \r\n        # Dynamics constraints\r\n        for k in range(N):\r\n            constraints.append(X[:, k+1] == A @ X[:, k] + B @ U[:, k])\r\n        \r\n        # ZMP constraints (must be within foot for stability)\r\n        for k in range(N):\r\n            # For simplicity, assume feet remain fixed for this prediction\r\n            # In reality, you\'d have moving support polygons\r\n            constraints.append(cp.norm(U[:, k], \'inf\') <= 0.3)  # ZMP within reasonable bounds\r\n        \r\n        # Create and solve problem\r\n        problem = cp.Problem(cp.Minimize(cost), constraints)\r\n        \r\n        return problem, X, U\r\n    \r\n    def solve_mpc(self):\r\n        """Solve the MPC optimization problem"""\r\n        # Create reference trajectory\r\n        reference_trajectory = self.generate_reference_trajectory()\r\n        \r\n        # Set up optimization problem\r\n        problem, X, U = self.setup_mpc_problem(self.state, reference_trajectory)\r\n        \r\n        try:\r\n            # Solve the problem\r\n            problem.solve(solver=cp.CLARABEL, verbose=False)\r\n            \r\n            if problem.status not in ["infeasible", "unbounded"]:\r\n                # Extract optimal control\r\n                optimal_controls = U.value\r\n                optimal_states = X.value\r\n                \r\n                # Return the first control input\r\n                if optimal_controls is not None and optimal_controls.shape[1] > 0:\r\n                    first_control = optimal_controls[:, 0]\r\n                    return first_control, optimal_states\r\n                else:\r\n                    self.get_logger().warn(\'MPC solution invalid\')\r\n                    return np.array([0.0, 0.0]), self.state.reshape(4,1)\r\n            else:\r\n                self.get_logger().warn(f\'MPC problem status: {problem.status}\')\r\n                # Return zero control if optimization fails\r\n                return np.array([0.0, 0.0]), self.state.reshape(4,1)\r\n        except Exception as e:\r\n            self.get_logger().error(f\'MPC optimization failed: {str(e)}\')\r\n            return np.array([0.0, 0.0]), self.state.reshape(4,1)\r\n    \r\n    def generate_reference_trajectory(self):\r\n        """Generate a reference trajectory for the MPC"""\r\n        N = self.prediction_horizon\r\n        ref_traj = np.zeros((4, N+1))\r\n        \r\n        # For walking, we want to follow a path while maintaining balance\r\n        current_time = self.get_clock().now().seconds_nanoseconds()[0]\r\n        \r\n        for k in range(N+1):\r\n            t = current_time + k * self.dt\r\n            \r\n            # Forward progression\r\n            x_ref = self.step_length * t / self.step_duration\r\n            \r\n            # Lateral oscillation (for walking gait)\r\n            if self.support_foot == "left":\r\n                y_ref = 0.1 * math.sin(2 * math.pi * t / (2 * self.step_duration))\r\n            else:\r\n                y_ref = 0.1 * math.sin(2 * math.pi * t / (2 * self.step_duration))\r\n            \r\n            # For now, assume zero velocity in reference (this is simplified)\r\n            ref_traj[:, k] = [x_ref, y_ref, 0, 0]\r\n        \r\n        return ref_traj\r\n    \r\n    def mpc_control_step(self):\r\n        """Main MPC control step"""\r\n        # Solve MPC problem\r\n        zmp_cmd, state_traj = self.solve_mpc()\r\n        \r\n        # Publish ZMP command\r\n        zmp_msg = Point()\r\n        zmp_msg.x = float(zmp_cmd[0])\r\n        zmp_msg.y = float(zmp_cmd[1])\r\n        zmp_msg.z = 0.0  # ZMP is on ground plane\r\n        self.zmp_pub.publish(zmp_msg)\r\n        \r\n        # Publish CoM trajectory\r\n        traj_msg = Float64MultiArray()\r\n        traj_msg.data = state_traj.flatten().tolist()\r\n        self.com_traj_pub.publish(traj_msg)\r\n        \r\n        # Publish CoM velocity\r\n        vel_msg = Twist()\r\n        vel_msg.linear.x = float(self.state[2])  # x velocity\r\n        vel_msg.linear.y = float(self.state[3])  # y velocity\r\n        self.com_vel_pub.publish(vel_msg)\r\n        \r\n        # Update status\r\n        status_msg = String()\r\n        status_msg.data = f"MPC Active  State: [{self.state[0]:.3f}, {self.state[1]:.3f}, {self.state[2]:.3f}, {self.state[3]:.3f}]"\r\n        self.mpc_status_pub.publish(status_msg)\r\n        \r\n        # Simple integration to update state (in reality, this would come from sensors)\r\n        A_cont = np.array([\r\n            [0, 0, 1, 0],\r\n            [0, 0, 0, 1],\r\n            [self.omega**2, 0, 0, 0],\r\n            [0, self.omega**2, 0, 0]\r\n        ])\r\n        \r\n        A = np.eye(4) + self.dt * A_cont\r\n        B = self.dt * np.array([\r\n            [0, 0],\r\n            [0, 0],\r\n            [self.omega**2, 0],\r\n            [0, self.omega**2]\r\n        ])\r\n        \r\n        # Update state: x_{k+1} = A*x_k + B*u_k\r\n        self.state = A @ self.state + B @ zmp_cmd\r\n        \r\n        self.get_logger().debug(f\'MPC Step  ZMP Cmd: ({zmp_cmd[0]:.3f}, {zmp_cmd[1]:.3f})\')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    controller = MPCWalkingController()\r\n    \r\n    try:\r\n        rclpy.spin(controller)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        controller.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"runnable-code-example",children:"Runnable Code Example"}),"\n",(0,o.jsx)(e.p,{children:"Here's a complete bipedal walking simulation with balance control:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n# complete_bipedal_controller.py\r\n\r\nimport numpy as np\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState, Imu\r\nfrom geometry_msgs.msg import Point, Twist\r\nfrom std_msgs.msg import Float64MultiArray, String\r\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\r\nfrom builtin_interfaces.msg import Duration\r\nfrom tf2_ros import TransformBroadcaster\r\nfrom geometry_msgs.msg import TransformStamped\r\nimport math\r\n\r\nclass CompleteBipedalController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'complete_bipedal_controller\')\r\n        \r\n        # Robot configuration\r\n        self.hip_offset = 0.15  # Lateral hip offset (m)\r\n        self.leg_length = 0.8   # Total leg length (m)\r\n        self.robot_height = 0.84  # Stance height (m)\r\n        \r\n        # Walking parameters\r\n        self.step_length = 0.3\r\n        self.step_height = 0.05\r\n        self.step_duration = 1.0\r\n        self.nominal_width = 0.2\r\n        \r\n        # State variables\r\n        self.robot_x = 0.0\r\n        self.robot_y = 0.0\r\n        self.robot_yaw = 0.0\r\n        self.left_foot_pos = np.array([0.0, self.hip_offset, 0.0])\r\n        self.right_foot_pos = np.array([0.0, self.hip_offset, 0.0])\r\n        self.com_pos = np.array([0.0, 0.0, self.robot_height])\r\n        \r\n        # Walking state machine\r\n        self.phase = "stance"  # "stance", "left_swing", "right_swing", "double_support"\r\n        self.swing_leg = "right"\r\n        self.step_phase = 0.0  # 0.0 to 1.0\r\n        self.last_step_time = self.get_clock().now().nanoseconds / 1e9\r\n        \r\n        # Timing\r\n        self.dt = 0.01  # 100 Hz control loop\r\n        \r\n        # TF broadcaster\r\n        self.tf_broadcaster = TransformBroadcaster(self)\r\n        \r\n        # Subscribers\r\n        self.joint_state_sub = self.create_subscription(\r\n            JointState, \'/joint_states\', self.joint_state_callback, 10)\r\n        \r\n        # Publishers\r\n        self.joint_trajectory_pub = self.create_publisher(\r\n            JointTrajectory, \'/joint_trajectory\', 10)\r\n        self.com_pub = self.create_publisher(\r\n            Point, \'/center_of_mass\', 10)\r\n        self.state_pub = self.create_publisher(\r\n            String, \'/walking_state\', 10)\r\n        self.foot_pos_pub = self.create_publisher(\r\n            Float64MultiArray, \'/foot_positions\', 10)\r\n        \r\n        # Timer for control loop\r\n        self.control_timer = self.create_timer(self.dt, self.control_step)\r\n        \r\n        self.get_logger().info(\'Complete Bipedal Controller initialized\')\r\n    \r\n    def joint_state_callback(self, msg):\r\n        """Update robot state from joint feedback"""\r\n        # In a real implementation, this would integrate joint positions\r\n        # to update robot pose estimates\r\n        pass\r\n    \r\n    def compute_inverse_kinematics(self, foot_pos, leg_side):\r\n        """Compute joint angles for a given foot position"""\r\n        # Simplified inverse kinematics for planar leg\r\n        # foot_pos is [x, y, z] relative to hip\r\n        \r\n        # Calculate hiptofoot vector\r\n        dx = foot_pos[0]\r\n        dy = foot_pos[1]  (self.hip_offset if leg_side == "left" else self.hip_offset)\r\n        dz = foot_pos[2]  self.robot_height  # Hip height is at torso level\r\n        \r\n        # Calculate leg length\r\n        leg_length_sq = dx*dx + dy*dy + dz*dz\r\n        leg_length = math.sqrt(leg_length_sq)\r\n        \r\n        # Check if position is reachable\r\n        if leg_length > 2 * self.leg_length:\r\n            self.get_logger().warn(f\'Foot position {foot_pos} not reachable\')\r\n            return [0.0, 0.0, 0.0]  # Return neutral position\r\n        \r\n        # Hip pitch (sagittal plane)\r\n        hip_pitch = math.atan2(dz, math.sqrt(dx*dx + dy*dy))\r\n        \r\n        # Hip roll (coronal plane)\r\n        hip_roll = math.atan2(dy, math.sqrt(dx*dx + dz*dz))\r\n        \r\n        # Knee angle (to straighten leg)\r\n        # Using law of cosines to find knee angle\r\n        a = self.leg_length\r\n        b = self.leg_length\r\n        c = leg_length\r\n        \r\n        if a > 0 and b > 0 and c > 0:\r\n            knee_angle = math.pi  math.acos((a*a + b*b  c*c) / (2*a*b))\r\n        else:\r\n            knee_angle = 0.0\r\n        \r\n        return [hip_roll, hip_pitch, knee_angle]\r\n    \r\n    def generate_walking_pattern(self):\r\n        """Generate walking pattern for the current phase"""\r\n        current_time = self.get_clock().now().nanoseconds / 1e9\r\n        time_in_step = current_time  self.last_step_time\r\n        self.step_phase = time_in_step / self.step_duration\r\n        \r\n        if self.step_phase >= 1.0:\r\n            # Step complete, switch legs\r\n            if self.swing_leg == "right":\r\n                self.swing_leg = "left"\r\n                self.left_foot_pos[0] = self.robot_x + self.step_length\r\n                self.left_foot_pos[1] = self.hip_offset if self.phase == "stance" else self.hip_offset\r\n            else:\r\n                self.swing_leg = "right"\r\n                self.right_foot_pos[0] = self.robot_x + self.step_length\r\n                self.right_foot_pos[1] = self.hip_offset if self.phase == "stance" else self.hip_offset\r\n            \r\n            self.last_step_time = current_time\r\n            self.step_phase = 0.0\r\n            self.robot_x += self.step_length  # Update robot position\r\n        \r\n        # Calculate swing foot trajectory\r\n        if self.swing_leg == "right":\r\n            # Right foot is swinging forward\r\n            swing_progress = min(self.step_phase * 2, 1.0)  # Swing phase is first half of step\r\n            target_x = self.robot_x + swing_progress * self.step_length\r\n            target_y = self.hip_offset  # Start and end at nominal width\r\n            \r\n            # Vertical trajectory (cycloid or similar)\r\n            if swing_progress < 0.5:\r\n                # Rise\r\n                swing_vertical = swing_progress * 2 * self.step_height\r\n            else:\r\n                # Fall\r\n                fall_progress = (swing_progress  0.5) * 2\r\n                swing_vertical = self.step_height * (1  fall_progress)\r\n            \r\n            self.right_foot_pos = np.array([target_x, target_y, swing_vertical])\r\n        else:\r\n            # Left foot is swinging\r\n            swing_progress = min(self.step_phase * 2, 1.0)\r\n            target_x = self.robot_x + swing_progress * self.step_length\r\n            target_y = self.hip_offset\r\n            \r\n            if swing_progress < 0.5:\r\n                swing_vertical = swing_progress * 2 * self.step_height\r\n            else:\r\n                fall_progress = (swing_progress  0.5) * 2\r\n                swing_vertical = self.step_height * (1  fall_progress)\r\n            \r\n            self.left_foot_pos = np.array([target_x, target_y, swing_vertical])\r\n        \r\n        # Update CoM position for balance (simplified)\r\n        # Keep CoM between feet\r\n        avg_foot_x = (self.left_foot_pos[0] + self.right_foot_pos[0]) / 2\r\n        avg_foot_y = (self.left_foot_pos[1] + self.right_foot_pos[1]) / 2\r\n        \r\n        # Add some lateral offset toward stance foot\r\n        stance_foot = "left" if self.swing_leg == "right" else "right"\r\n        if stance_foot == "left":\r\n            com_offset_y = 0.02  # Slightly toward left foot\r\n        else:\r\n            com_offset_y = 0.02   # Slightly toward right foot\r\n        \r\n        self.com_pos[0] = avg_foot_x\r\n        self.com_pos[1] = avg_foot_y + com_offset_y\r\n        self.com_pos[2] = self.robot_height\r\n    \r\n    def publish_joint_commands(self):\r\n        """Publish joint trajectory commands"""\r\n        trajectory_msg = JointTrajectory()\r\n        trajectory_msg.joint_names = [\r\n            \'left_hip_joint\', \'left_knee_joint\', \'right_hip_joint\', \'right_knee_joint\',\r\n            \'left_ankle_joint\', \'right_ankle_joint\', \'left_shoulder_joint\', \'right_shoulder_joint\'\r\n        ]\r\n        \r\n        point = JointTrajectoryPoint()\r\n        \r\n        # Compute joint angles using inverse kinematics\r\n        left_angles = self.compute_inverse_kinematics(self.left_foot_pos, "left")\r\n        right_angles = self.compute_inverse_kinematics(self.right_foot_pos, "right")\r\n        \r\n        # For this simplified version, we\'ll use just hip and knee angles\r\n        # More complex implementation would include ankle, etc.\r\n        point.positions = [\r\n            left_angles[0],           # left_hip_roll\r\n            left_angles[1],           # left_hip_pitch\r\n            right_angles[0],          # right_hip_roll\r\n            right_angles[1],          # right_hip_pitch\r\n            left_angles[2],           # left_knee\r\n            right_angles[2],          # right_knee\r\n            0.0,                      # left_shoulder (for balance)\r\n            0.0                       # right_shoulder (for balance)\r\n        ]\r\n        \r\n        # Set zero velocities and accelerations\r\n        point.velocities = [0.0] * len(point.positions)\r\n        point.accelerations = [0.0] * len(point.positions)\r\n        \r\n        # Set time from start\r\n        point.time_from_start = Duration(sec=0, nanosec=int(self.dt * 1e9))\r\n        \r\n        trajectory_msg.points.append(point)\r\n        self.joint_trajectory_pub.publish(trajectory_msg)\r\n    \r\n    def broadcast_transforms(self):\r\n        """Broadcast TF transforms for visualization"""\r\n        current_time = self.get_clock().now()\r\n        \r\n        # Robot base frame\r\n        t = TransformStamped()\r\n        t.header.stamp = current_time.to_msg()\r\n        t.header.frame_id = \'world\'\r\n        t.child_frame_id = \'base_link\'\r\n        t.transform.translation.x = float(self.com_pos[0])\r\n        t.transform.translation.y = float(self.com_pos[1])\r\n        t.transform.translation.z = float(self.com_pos[2])\r\n        t.transform.rotation.x = 0.0\r\n        t.transform.rotation.y = 0.0\r\n        t.transform.rotation.z = 0.0\r\n        t.transform.rotation.w = 1.0\r\n        self.tf_broadcaster.sendTransform(t)\r\n        \r\n        # Left foot frame\r\n        t.child_frame_id = \'left_foot\'\r\n        t.transform.translation.x = float(self.left_foot_pos[0])\r\n        t.transform.translation.y = float(self.left_foot_pos[1])\r\n        t.transform.translation.z = float(self.left_foot_pos[2])\r\n        self.tf_broadcaster.sendTransform(t)\r\n        \r\n        # Right foot frame\r\n        t.child_frame_id = \'right_foot\'\r\n        t.transform.translation.x = float(self.right_foot_pos[0])\r\n        t.transform.translation.y = float(self.right_foot_pos[1])\r\n        t.transform.translation.z = float(self.right_foot_pos[2])\r\n        self.tf_broadcaster.sendTransform(t)\r\n    \r\n    def control_step(self):\r\n        """Main control step"""\r\n        # Generate walking pattern\r\n        self.generate_walking_pattern()\r\n        \r\n        # Publish commands\r\n        self.publish_joint_commands()\r\n        \r\n        # Broadcast transforms\r\n        self.broadcast_transforms()\r\n        \r\n        # Publish state information\r\n        com_msg = Point()\r\n        com_msg.x = float(self.com_pos[0])\r\n        com_msg.y = float(self.com_pos[1])\r\n        com_msg.z = float(self.com_pos[2])\r\n        self.com_pub.publish(com_msg)\r\n        \r\n        # Publish foot positions\r\n        foot_pos_msg = Float64MultiArray()\r\n        foot_pos_msg.data = [\r\n            float(self.left_foot_pos[0]), float(self.left_foot_pos[1]), float(self.left_foot_pos[2]),\r\n            float(self.right_foot_pos[0]), float(self.right_foot_pos[1]), float(self.right_foot_pos[2])\r\n        ]\r\n        self.foot_pos_pub.publish(foot_pos_msg)\r\n        \r\n        # Publish state\r\n        state_msg = String()\r\n        state_msg.data = f"Phase: {self.phase}, Swing: {self.swing_leg}, Step: {self.step_phase:.2f}"\r\n        self.state_pub.publish(state_msg)\r\n        \r\n        # Log progress\r\n        self.get_logger().debug(\r\n            f\'Walking: CoM=({self.com_pos[0]:.3f}, {self.com_pos[1]:.3f}, {self.com_pos[2]:.3f}), \'\r\n            f\'Left_foot=({self.left_foot_pos[0]:.3f}, {self.left_foot_pos[1]:.3f}), \'\r\n            f\'Right_foot=({self.right_foot_pos[0]:.3f}, {self.right_foot_pos[1]:.3f})\'\r\n        )\r\n\r\nclass BalanceRecoveryController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'balance_recovery_controller\')\r\n        \r\n        # Subscribe to CoM and foot position data\r\n        self.com_sub = self.create_subscription(\r\n            Point, \'/center_of_mass\', self.com_callback, 10)\r\n        self.foot_pos_sub = self.create_subscription(\r\n            Float64MultiArray, \'/foot_positions\', self.foot_pos_callback, 10)\r\n        \r\n        # Publisher for recovery commands\r\n        self.recovery_cmd_pub = self.create_publisher(\r\n            Twist, \'/recovery_command\', 10)\r\n        \r\n        # State variables\r\n        self.com_pos = np.array([0.0, 0.0, 0.84])\r\n        self.left_foot = np.array([0.0, 0.15, 0.0])\r\n        self.right_foot = np.array([0.0, 0.15, 0.0])\r\n        self.recovery_active = False\r\n        \r\n        # Recovery parameters\r\n        self.stability_threshold = 0.15  # meters from foot center\r\n        self.recovery_gain = 2.0\r\n        \r\n        # Timer for recovery check\r\n        self.recovery_timer = self.create_timer(0.05, self.check_stability)  # 20 Hz\r\n        \r\n        self.get_logger().info(\'Balance Recovery Controller initialized\')\r\n    \r\n    def com_callback(self, msg):\r\n        self.com_pos = np.array([msg.x, msg.y, msg.z])\r\n    \r\n    def foot_pos_callback(self, msg):\r\n        if len(msg.data) >= 6:\r\n            self.left_foot = np.array(msg.data[0:3])\r\n            self.right_foot = np.array(msg.data[3:6])\r\n    \r\n    def check_stability(self):\r\n        """Check if robot is in danger of falling and initiate recovery"""\r\n        # Calculate ZMP (simplified as CoM position projected to ground)\r\n        zmp_x = self.com_pos[0]\r\n        zmp_y = self.com_pos[1]\r\n        \r\n        # Determine support polygon (convex hull of feet)\r\n        if self.left_foot[2] < 0.01 and self.right_foot[2] < 0.01:\r\n            # Both feet on ground  double support\r\n            min_y = min(self.left_foot[1], self.right_foot[1])\r\n            max_y = max(self.left_foot[1], self.right_foot[1])\r\n            center_y = (min_y + max_y) / 2\r\n            support_width = max_y  min_y\r\n        elif self.left_foot[2] < 0.01:\r\n            # Left foot support\r\n            center_y = self.left_foot[1]\r\n            support_width = 0.1  # Approximate foot size\r\n        elif self.right_foot[2] < 0.01:\r\n            # Right foot support\r\n            center_y = self.right_foot[1]\r\n            support_width = 0.1  # Approximate foot size\r\n        else:\r\n            # No support  critical condition\r\n            self.get_logger().error(\'NO FOOT SUPPORT  EMERGENCY!\')\r\n            return\r\n        \r\n        # Check if ZMP is outside support region\r\n        margin = support_width / 2  self.stability_threshold\r\n        if abs(zmp_y  center_y) > margin:\r\n            # Robot is in danger of falling laterally\r\n            self.initiate_lateral_recovery(zmp_y, center_y)\r\n        elif abs(zmp_x  (self.left_foot[0] + self.right_foot[0]) / 2) > 0.2:\r\n            # Robot is in danger of falling forward/backward\r\n            self.initiate_angular_recovery(zmp_x)\r\n        else:\r\n            # Stable, reduce recovery if active\r\n            if self.recovery_active:\r\n                self.recovery_active = False\r\n                self.get_logger().info(\'Stability restored\')\r\n    \r\n    def initiate_lateral_recovery(self, zmp_y, support_center_y):\r\n        """Initiate lateral balance recovery"""\r\n        self.recovery_active = True\r\n        \r\n        # Generate recovery command to shift CoM back to safe area\r\n        recovery_cmd = Twist()\r\n        recovery_cmd.linear.y = self.recovery_gain * (zmp_y  support_center_y)\r\n        recovery_cmd.angular.z = 0.3 * (zmp_y  support_center_y)  # Counterrotate\r\n        \r\n        self.recovery_cmd_pub.publish(recovery_cmd)\r\n        \r\n        self.get_logger().warn(\r\n            f\'Lateral recovery activated: ZMP Y={zmp_y:.3f}, Center Y={support_center_y:.3f}, \'\r\n            f\'Correction Y cmd={recovery_cmd.linear.y:.3f}\'\r\n        )\r\n    \r\n    def initiate_angular_recovery(self, zmp_x):\r\n        """Initiate forward/backward balance recovery"""\r\n        self.recovery_active = True\r\n        \r\n        # Generate recovery command to pitch the robot\r\n        recovery_cmd = Twist()\r\n        recovery_cmd.linear.x = 0.0  # Forward/backward motion\r\n        recovery_cmd.angular.y = 0.2 * (zmp_x  (self.left_foot[0] + self.right_foot[0]) / 2)\r\n        \r\n        self.recovery_cmd_pub.publish(recovery_cmd)\r\n        \r\n        self.get_logger().warn(\r\n            f\'Angular recovery activated: ZMP X={zmp_x:.3f}, \'\r\n            f\'Correction pitch cmd={recovery_cmd.angular.y:.3f}\'\r\n        )\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    \r\n    # Create both controllers\r\n    walking_controller = CompleteBipedalController()\r\n    balance_controller = BalanceRecoveryController()\r\n    \r\n    try:\r\n        # Create executor and add both nodes\r\n        executor = rclpy.executors.MultiThreadedExecutor()\r\n        executor.add_node(walking_controller)\r\n        executor.add_node(balance_controller)\r\n        \r\n        # Spin both nodes\r\n        executor.spin()\r\n        \r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        walking_controller.destroy_node()\r\n        balance_controller.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,o.jsx)(e.h2,{id:"miniproject",children:"Miniproject"}),"\n",(0,o.jsx)(e.p,{children:"Create a complete bipedal locomotion system that:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Implements both LIPM and MPC balance controllers"}),"\n",(0,o.jsx)(e.li,{children:"Simulates a 3D bipedal robot in Isaac Sim with realistic physics"}),"\n",(0,o.jsx)(e.li,{children:"Generates stable walking gaits with proper footstep planning"}),"\n",(0,o.jsx)(e.li,{children:"Implements balance recovery strategies for perturbations"}),"\n",(0,o.jsx)(e.li,{children:"Evaluates stability margins and performance metrics"}),"\n",(0,o.jsx)(e.li,{children:"Includes visualization of ZMP, CoM, and footstep plans"}),"\n",(0,o.jsx)(e.li,{children:"Tests the system with various perturbations and uneven terrain"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Your project should include:\r\nComplete robot model with proper dynamics\r\nLIPM and MPC controllers implementation\r\nFootstep planning algorithm\r\nBalance recovery system\r\nPerformance evaluation metrics\r\nIsaac Sim integration for realistic physics simulation"}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"This chapter covered bipedal locomotion and balance control:"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"LIPM Control"}),": Linear Inverted Pendulum Model for balance control\r\n",(0,o.jsx)(e.strong,{children:"MPC Walking"}),": Model Predictive Control for dynamic walking patterns\r\n",(0,o.jsx)(e.strong,{children:"Gait Generation"}),": Creating stable walking patterns with proper foot placement\r\n",(0,o.jsx)(e.strong,{children:"Balance Recovery"}),": Strategies to maintain stability during perturbations\r\n",(0,o.jsx)(e.strong,{children:"Simulation"}),": Using Isaac Sim for realistic bipedal robot simulation\r\n",(0,o.jsx)(e.strong,{children:"Control Integration"}),": Combining multiple control strategies for robust locomotion"]}),"\n",(0,o.jsx)(e.p,{children:"Bipedal locomotion requires sophisticated control algorithms that account for the underactuated nature of bipedal systems while maintaining stability through careful foot placement and CoM control."})]})}function m(r={}){const{wrapper:e}={...(0,i.R)(),...r.components};return e?(0,o.jsx)(e,{...r,children:(0,o.jsx)(f,{...r})}):f(r)}}}]);