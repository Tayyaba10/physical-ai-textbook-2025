"use strict";(globalThis.webpackChunkai_native_robotics_textbook=globalThis.webpackChunkai_native_robotics_textbook||[]).push([[9719],{8958:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>_,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-4-vision-language-action/ch18-cognitive-task-planning-gpt4o","title":"ch18-cognitive-task-planning-gpt4o","description":"-----","source":"@site/docs/module-4-vision-language-action/ch18-cognitive-task-planning-gpt4o.md","sourceDirName":"module-4-vision-language-action","slug":"/module-4-vision-language-action/ch18-cognitive-task-planning-gpt4o","permalink":"/physical-ai-textbook-2025/docs/module-4-vision-language-action/ch18-cognitive-task-planning-gpt4o","draft":false,"unlisted":false,"editUrl":"https://github.com/Tayyaba10/physical-ai-textbook-2025/edit/main/docs/module-4-vision-language-action/ch18-cognitive-task-planning-gpt4o.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"ch17-voice-to-action-whisper","permalink":"/physical-ai-textbook-2025/docs/module-4-vision-language-action/ch17-voice-to-action-whisper"},"next":{"title":"ch19-multimodal-perception-fusion","permalink":"/physical-ai-textbook-2025/docs/module-4-vision-language-action/ch19-multimodal-perception-fusion"}}');var a=r(4848),s=r(8453),i=r(7242);const o={},l=void 0,p={},c=[{value:"title: Ch18  Cognitive Task Planning with GPT4o\r\nmodule: 4\r\nchapter: 18\r\nsidebar_label: Ch18: Cognitive Task Planning with GPT4o\r\ndescription: Implementing cognitive task planning using GPT4o for complex robotic manipulation and navigation\r\ntags: [gpt4o, cognitiveplanning, taskplanning, robotics, aiplanning, hierarchicaltasknetwork, ros2]\r\ndifficulty: advanced\r\nestimated_duration: 150",id:"title-ch18--cognitive-task-planning-with-gpt4omodule-4chapter-18sidebar_label-ch18-cognitive-task-planning-with-gpt4odescription-implementing-cognitive-task-planning-using-gpt4o-for-complex-robotic-manipulation-and-navigationtags-gpt4o-cognitiveplanning-taskplanning-robotics-aiplanning-hierarchicaltasknetwork-ros2difficulty-advancedestimated_duration-150",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Theory",id:"theory",level:2},{value:"Cognitive Task Planning in Robotics",id:"cognitive-task-planning-in-robotics",level:3},{value:"GPT4o for Task Planning",id:"gpt4o-for-task-planning",level:3},{value:"Hierarchical Task Networks (HTNs)",id:"hierarchical-task-networks-htns",level:3},{value:"Plan Representation",id:"plan-representation",level:3},{value:"StepbyStep Labs",id:"stepbystep-labs",level:2},{value:"Lab 1: Setting up GPT4o for Task Planning",id:"lab-1-setting-up-gpt4o-for-task-planning",level:3},{value:"Lab 2: Implementing Hierarchical Task Networks",id:"lab-2-implementing-hierarchical-task-networks",level:3},{value:"Lab 3: Integrating with Behavior Trees for Execution",id:"lab-3-integrating-with-behavior-trees-for-execution",level:3},{value:"Runnable Code Example",id:"runnable-code-example",level:2},{value:"Miniproject",id:"miniproject",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"title-ch18--cognitive-task-planning-with-gpt4omodule-4chapter-18sidebar_label-ch18-cognitive-task-planning-with-gpt4odescription-implementing-cognitive-task-planning-using-gpt4o-for-complex-robotic-manipulation-and-navigationtags-gpt4o-cognitiveplanning-taskplanning-robotics-aiplanning-hierarchicaltasknetwork-ros2difficulty-advancedestimated_duration-150",children:"title: Ch18  Cognitive Task Planning with GPT4o\r\nmodule: 4\r\nchapter: 18\r\nsidebar_label: Ch18: Cognitive Task Planning with GPT4o\r\ndescription: Implementing cognitive task planning using GPT4o for complex robotic manipulation and navigation\r\ntags: [gpt4o, cognitiveplanning, taskplanning, robotics, aiplanning, hierarchicaltasknetwork, ros2]\r\ndifficulty: advanced\r\nestimated_duration: 150"}),"\n","\n",(0,a.jsx)(n.h1,{id:"cognitive-task-planning-with-gpt4o",children:"Cognitive Task Planning with GPT4o"}),"\n",(0,a.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,a.jsx)(n.p,{children:"Implement cognitive task planning using OpenAI's GPT4o model\r\nDesign hierarchical task decomposition for complex robotic tasks\r\nIntegrate LLMbased planning with traditional robotic planning systems\r\nCreate contextaware task planners that understand the environment\r\nImplement plan execution monitoring and recovery\r\nDesign feedback mechanisms for plan refinement\r\nEvaluate cognitive planning performance and robustness\r\nHandle ambiguity and uncertainty in task specifications"}),"\n",(0,a.jsx)(n.h2,{id:"theory",children:"Theory"}),"\n",(0,a.jsx)(n.h3,{id:"cognitive-task-planning-in-robotics",children:"Cognitive Task Planning in Robotics"}),"\n",(0,a.jsx)(n.p,{children:"Cognitive task planning involves highlevel reasoning about complex tasks that require understanding of the environment, objects, and their relationships. This contrasts with lowlevel motion planning which deals with trajectory generation and collision avoidance."}),"\n",(0,a.jsx)(i.A,{chart:"\ngraph TD;\n  A[HighLevel Task] > B[Task Decomposition];\n  B > C[Subtask Identification];\n  C > D[Primitive Action Sequences];\n  D > E[LowLevel Controllers];\n  \n  F[Environmental Context] > G[Perception System];\n  G > H[Object Recognition];\n  H > I[Spatial Reasoning];\n  \n  B > J[Context Integration];\n  C > J;\n  I > J;\n  \n  J > K[Plan Generation];\n  K > L[Plan Validation];\n  L > M[Plan Execution];\n  M > N[Monitoring & Recovery];\n  \n  style A fill:#4CAF50,stroke:#388E3C,color:#fff;\n  style K fill:#2196F3,stroke:#0D47A1,color:#fff;\n  style M fill:#FF9800,stroke:#E65100,color:#fff;\n"}),"\n",(0,a.jsx)(n.h3,{id:"gpt4o-for-task-planning",children:"GPT4o for Task Planning"}),"\n",(0,a.jsx)(n.p,{children:"GPT4o provides several advantages for cognitive task planning:"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"World Knowledge"}),": Understanding of physical objects, their properties, and relationships\r\n",(0,a.jsx)(n.strong,{children:"Logical Reasoning"}),": Ability to reason about cause and effect, preconditions and effects\r\n",(0,a.jsx)(n.strong,{children:"Contextual Understanding"}),": Ability to understand the environment and adapt plans accordingly\r\n",(0,a.jsx)(n.strong,{children:"Natural Language Interface"}),": Easy specification of tasks using natural language"]}),"\n",(0,a.jsx)(n.h3,{id:"hierarchical-task-networks-htns",children:"Hierarchical Task Networks (HTNs)"}),"\n",(0,a.jsx)(n.p,{children:"HTNs break down complex tasks into hierarchically organized subtasks. The planning process involves decomposing highlevel tasks into more specific subtasks until primitive actions are reached."}),"\n",(0,a.jsx)(n.h3,{id:"plan-representation",children:"Plan Representation"}),"\n",(0,a.jsxs)(n.p,{children:["Plans can be represented as:\r\n",(0,a.jsx)(n.strong,{children:"Sequential"}),": Linear sequence of actions\r\n",(0,a.jsx)(n.strong,{children:"Partial Order"}),": Actions with temporal constraints\r\n",(0,a.jsx)(n.strong,{children:"Contingent"}),": Plans with conditional branches based on sensing results\r\n",(0,a.jsx)(n.strong,{children:"Hierarchical"}),": Tree structure of decomposed tasks"]}),"\n",(0,a.jsx)(n.h2,{id:"stepbystep-labs",children:"StepbyStep Labs"}),"\n",(0,a.jsx)(n.h3,{id:"lab-1-setting-up-gpt4o-for-task-planning",children:"Lab 1: Setting up GPT4o for Task Planning"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Install required dependencies"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"pip install openai==1.3.5\r\npip install langchain langchainopenai\r\npip install numpy scipy\r\npip install gymnasium\r\npip install ros2 rospy\r\npip install py_trees  # Behavior trees library\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Create a GPT4o task planning interface"})," (",(0,a.jsx)(n.code,{children:"gpt_task_planner.py"}),"):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n\r\nimport openai\r\nimport json\r\nimport rospy\r\nimport py_trees\r\nfrom std_msgs.msg import String, Bool\r\nfrom geometry_msgs.msg import Pose\r\nfrom actionlib_msgs.msg import GoalStatusArray\r\nfrom typing import Dict, List, Optional, Any\r\nimport time\r\nimport yaml\r\n\r\nclass GPTTaskPlanner:\r\n    def __init__(self, api_key: str, model_name: str = "gpt4o"):\r\n        openai.api_key = api_key\r\n        self.client = openai.OpenAI(api_key=api_key)\r\n        self.model_name = model_name\r\n        \r\n        # Initialize ROS node\r\n        rospy.init_node(\'gpt_task_planner\', anonymous=True)\r\n        \r\n        # Publishers and Subscribers\r\n        self.plan_pub = rospy.Publisher(\'/generated_plan\', String, queue_size=10)\r\n        self.status_pub = rospy.Publisher(\'/planner_status\', String, queue_size=10)\r\n        self.feedback_pub = rospy.Publisher(\'/planner_feedback\', String, queue_size=10)\r\n        rospy.Subscriber(\'/task_request\', String, self.task_request_callback)\r\n        rospy.Subscriber(\'/execution_feedback\', String, self.execution_feedback_callback)\r\n        \r\n        # Environment state\r\n        self.environment_state = {}\r\n        self.current_plan = None\r\n        self.current_execution_step = 0\r\n        \r\n        # Task planning configuration\r\n        self.max_replanning_attempts = 3\r\n        self.plan_validity_timeout = 30  # seconds\r\n        \r\n        rospy.loginfo(f"GPT Task Planner initialized with model: {model_name}")\r\n    \r\n    def task_request_callback(self, msg: String):\r\n        """Handle incoming task requests"""\r\n        rospy.loginfo(f"Received task request: {msg.data}")\r\n        \r\n        task_description = msg.data\r\n        \r\n        # Plan the task\r\n        plan = self.generate_plan(task_description)\r\n        \r\n        if plan:\r\n            self.current_plan = plan\r\n            self.current_execution_step = 0\r\n            self.publish_plan(plan)\r\n            self.publish_status("Plan generated and published")\r\n        else:\r\n            self.publish_status("Failed to generate plan")\r\n    \r\n    def execution_feedback_callback(self, msg: String):\r\n        """Handle execution feedback"""\r\n        try:\r\n            feedback_data = json.loads(msg.data)\r\n            status = feedback_data.get("status", "")\r\n            step = feedback_data.get("step", 0)\r\n            \r\n            if status == "failure":\r\n                rospy.loginfo(f"Plan step {step} failed, attempting recovery")\r\n                self.handle_failure(step, feedback_data.get("error", ""))\r\n            elif status == "success":\r\n                rospy.loginfo(f"Plan step {step} completed successfully")\r\n                self.current_execution_step += 1\r\n            \r\n        except json.JSONDecodeError:\r\n            rospy.logerr("Failed to parse execution feedback")\r\n    \r\n    def generate_plan(self, task_description: str) > Optional[Dict]:\r\n        """Generate a task plan using GPT4o"""\r\n        # Get current environment context\r\n        context = self.get_environment_context()\r\n        \r\n        # Construct planning prompt\r\n        prompt = self.construct_planning_prompt(task_description, context)\r\n        \r\n        try:\r\n            response = self.client.chat.completions.create(\r\n                model=self.model_name,\r\n                messages=[\r\n                    {\r\n                        "role": "system",\r\n                        "content": """You are an expert robotic task planner. Generate detailed, executable plans for robotic tasks. \r\n                        Your response should be a valid JSON object with the following structure:\r\n                        {\r\n                          "task": "original task description",\r\n                          "reasoning": "detailed reasoning about the plan",\r\n                          "plan": [\r\n                            {\r\n                              "step": 1,\r\n                              "description": "what robot should do",\r\n                              "action": "action_type",\r\n                              "parameters": {"key": "value"},\r\n                              "preconditions": ["condition1", "condition2"],\r\n                              "effects": ["effect1", "effect2"]\r\n                            }\r\n                          ],\r\n                          "estimated_time": 120.0,\r\n                          "confidence": 0.9\r\n                        }\r\n                        \r\n                        Actions should be specific, executable robot commands.\r\n                        Precondition and effect descriptions should be in plain English.\r\n                        Do not include any text before or after the JSON."""\r\n                    },\r\n                    {\r\n                        "role": "user",\r\n                        "content": prompt\r\n                    }\r\n                ],\r\n                temperature=0.1,  # Low temperature for consistency\r\n                max_tokens=2000\r\n            )\r\n            \r\n            response_text = response.choices[0].message.content.strip()\r\n            \r\n            # Extract JSON from response (if wrapped in markdown)\r\n            if response_text.startswith(\'```\'):\r\n                # Find the first \'{\' and last \'}\'\r\n                start_idx = response_text.find(\'{\')\r\n                end_idx = response_text.rfind(\'}\') + 1\r\n                if start_idx != 1 and end_idx != 1:\r\n                    response_text = response_text[start_idx:end_idx]\r\n                else:\r\n                    rospy.logerr("Could not extract JSON from response")\r\n                    return None\r\n            \r\n            plan_data = json.loads(response_text)\r\n            rospy.loginfo(f"Generated plan with {len(plan_data[\'plan\'])} steps")\r\n            return plan_data\r\n            \r\n        except Exception as e:\r\n            rospy.logerr(f"Error generating plan: {e}")\r\n            return None\r\n    \r\n    def construct_planning_prompt(self, task_description: str, context: Dict) > str:\r\n        """Construct prompt for task planning"""\r\n        prompt = f"""\r\n        Task: {task_description}\r\n        \r\n        Environment Context: {json.dumps(context, indent=2)}\r\n        \r\n        Available Actions:\r\n         move_to_location(location_name): Move robot to named location\r\n         pick_object(object_name, grasp_pose): Pick up an object with specific grasp\r\n         place_object(object_name, location, placement_pose): Place object at location\r\n         open_object(object_name): Open a container or door\r\n         close_object(object_name): Close a container or door\r\n         detect_object(object_name): Detect presence of object in environment\r\n         navigate_to_object(object_name): Navigate close to an object\r\n         inspect_object(object_name): Inspect an object for damage or quality\r\n         transport_object(from_location, to_location): Transport an object\r\n        \r\n        Generate a detailed plan to accomplish the task. The plan should be executable and consider:\r\n        1. Preconditions for each step\r\n        2. Expected effects of each action\r\n        3. Potential failure modes\r\n        4. Environmental constraints\r\n        5. Object affordances\r\n        \r\n        The plan should be specific enough for direct robot execution.\r\n        """\r\n        return prompt\r\n    \r\n    def get_environment_context(self) > Dict:\r\n        """Get current environment context"""\r\n        # This would be populated from various ROS topics in a real implementation\r\n        return {\r\n            "known_locations": ["kitchen", "living_room", "bedroom", "office"],\r\n            "robot_pose": {"x": 0.0, "y": 0.0, "theta": 0.0},\r\n            "detected_objects": [\r\n                {"name": "apple", "location": "kitchen_table", "type": "food"},\r\n                {"name": "book", "location": "living_room_table", "type": "stationery"},\r\n                {"name": "water_bottle", "location": "desk", "type": "drink"}\r\n            ],\r\n            "available_tools": ["arm", "grasping_gripper"],\r\n            "current_inventory": [],\r\n            "time_of_day": "daytime"\r\n        }\r\n    \r\n    def publish_plan(self, plan: Dict):\r\n        """Publish the generated plan"""\r\n        plan_msg = String()\r\n        plan_msg.data = json.dumps(plan, indent=2)\r\n        self.plan_pub.publish(plan_msg)\r\n    \r\n    def publish_status(self, status: str):\r\n        """Publish planner status"""\r\n        status_msg = String()\r\n        status_msg.data = status\r\n        self.status_pub.publish(status_msg)\r\n    \r\n    def handle_failure(self, step_num: int, error: str):\r\n        """Handle plan execution failure"""\r\n        rospy.loginfo(f"Handling failure in step {step_num}: {error}")\r\n        \r\n        # Attempt recovery\r\n        recovery_plan = self.generate_recovery_plan(self.current_plan, step_num, error)\r\n        \r\n        if recovery_plan:\r\n            rospy.loginfo("Recovery plan generated, publishing...")\r\n            self.publish_plan(recovery_plan)\r\n            self.publish_status(f"Recovery plan generated for step {step_num}")\r\n        else:\r\n            rospy.logerr(f"Failed to generate recovery plan for step {step_num}")\r\n            self.publish_status(f"Recovery failed for step {step_num}")\r\n    \r\n    def generate_recovery_plan(self, original_plan: Dict, failed_step: int, error: str) > Optional[Dict]:\r\n        """Generate a recovery plan after failure"""\r\n        # Get environment context at the time of failure\r\n        context = self.get_environment_context()\r\n        \r\n        prompt = f"""\r\n        Original Task: {original_plan[\'task\']}\r\n        \r\n        Failed Step: {failed_step}\r\n        Original Step Plan: {json.dumps(original_plan[\'plan\'][failed_step1], indent=2)}\r\n        Error: {error}\r\n        \r\n        Current Environment: {json.dumps(context, indent=2)}\r\n        \r\n        Generate a recovery plan to address the failure and continue task completion.\r\n        The recovery plan should:\r\n        1. Address the specific failure that occurred\r\n        2. Resume task execution from an appropriate point\r\n        3. Consider the current environment state\r\n        4. Be executable by the robot\r\n        \r\n        Return the plan in the same JSON format as before.\r\n        """\r\n        \r\n        try:\r\n            response = self.client.chat.completions.create(\r\n                model=self.model_name,\r\n                messages=[\r\n                    {\r\n                        "role": "system",\r\n                        "content": """You are an expert robotic task recovery planner. Generate recovery plans that address specific failures and resume task execution. \r\n                        Respond with valid JSON as specified in the original planning system."""\r\n                    },\r\n                    {\r\n                        "role": "user",\r\n                        "content": prompt\r\n                    }\r\n                ],\r\n                temperature=0.1,\r\n                max_tokens=1500\r\n            )\r\n            \r\n            response_text = response.choices[0].message.content.strip()\r\n            \r\n            # Extract JSON\r\n            if response_text.startswith(\'```\'):\r\n                start_idx = response_text.find(\'{\')\r\n                end_idx = response_text.rfind(\'}\') + 1\r\n                if start_idx != 1 and end_idx != 1:\r\n                    response_text = response_text[start_idx:end_idx]\r\n                else:\r\n                    rospy.logerr("Could not extract JSON from recovery response")\r\n                    return None\r\n            \r\n            recovery_plan = json.loads(response_text)\r\n            return recovery_plan\r\n            \r\n        except Exception as e:\r\n            rospy.logerr(f"Error generating recovery plan: {e}")\r\n            return None\r\n    \r\n    def run(self):\r\n        """Run the planner node"""\r\n        rospy.loginfo("GPT Task Planner running...")\r\n        rospy.spin()\r\n\r\nif __name__ == \'__main__\':\r\n    # Initialize with OpenAI API key\r\n    api_key = rospy.get_param("~openai_api_key", "")\r\n    if not api_key:\r\n        api_key = input("Enter OpenAI API key: ")\r\n    \r\n    if not api_key:\r\n        rospy.logerr("No OpenAI API key provided!")\r\n        exit(1)\r\n    \r\n    planner = GPTTaskPlanner(api_key)\r\n    planner.run()\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"lab-2-implementing-hierarchical-task-networks",children:"Lab 2: Implementing Hierarchical Task Networks"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Create a hierarchical task network planner"})," (",(0,a.jsx)(n.code,{children:"htn_planner.py"}),"):","\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n\r\nimport openai\r\nimport json\r\nimport rospy\r\nimport py_trees\r\nfrom std_msgs.msg import String\r\nfrom typing import Dict, List, Optional, Union\r\nimport time\r\n\r\nclass HTNPlanner:\r\n    def __init__(self, api_key: str, model_name: str = "gpt4o"):\r\n        self.client = openai.OpenAI(api_key=api_key)\r\n        self.model_name = model_name\r\n        \r\n        # Initialize ROS\r\n        rospy.init_node(\'htn_planner\', anonymous=True)\r\n        \r\n        # Publishers and Subscribers\r\n        self.plan_pub = rospy.Publisher(\'/htn_plan\', String, queue_size=10)\r\n        self.status_pub = rospy.Publisher(\'/htn_status\', String, queue_size=10)\r\n        rospy.Subscriber(\'/htn_task_request\', String, self.task_request_callback)\r\n        \r\n        # Task templates for decomposition\r\n        self.task_templates = {\r\n            "move_object": {\r\n                "subtasks": [\r\n                    {"name": "navigate_to_object", "parameters": ["object_name", "navigation_pose"]},\r\n                    {"name": "grasp_object", "parameters": ["object_name", "grasp_pose"]},\r\n                    {"name": "navigate_to_destination", "parameters": ["destination", "navigation_pose"]},\r\n                    {"name": "release_object", "parameters": ["placement_pose"]}\r\n                ]\r\n            },\r\n            "assemble_objects": {\r\n                "subtasks": [\r\n                    {"name": "find_component", "parameters": ["component_type"]},\r\n                    {"name": "transport_component", "parameters": ["component", "assembly_station"]},\r\n                    {"name": "align_component", "parameters": ["component", "assembly_point"]},\r\n                    {"name": "fasten_component", "parameters": ["component", "fastening_method"]}\r\n                ]\r\n            },\r\n            "inspect_area": {\r\n                "subtasks": [\r\n                    {"name": "navigate_to_area", "parameters": ["area_name"]},\r\n                    {"name": "perform_visual_inspection", "parameters": ["inspection_targets"]},\r\n                    {"name": "analyze_results", "parameters": ["collected_data"]},\r\n                    {"name": "report_findings", "parameters": ["analysis_results"]}\r\n                ]\r\n            }\r\n        }\r\n        \r\n        rospy.loginfo("HTN Planner initialized")\r\n    \r\n    def task_request_callback(self, msg: String):\r\n        """Handle task request and generate HTN plan"""\r\n        rospy.loginfo(f"Processing HTN task: {msg.data}")\r\n        \r\n        plan = self.generate_htn_plan(msg.data)\r\n        \r\n        if plan:\r\n            rospy.loginfo(f"Generated HTN plan with {len(plan[\'tasks\'])} tasks")\r\n            plan_msg = String()\r\n            plan_msg.data = json.dumps(plan, indent=2)\r\n            self.plan_pub.publish(plan_msg)\r\n        else:\r\n            rospy.logerr("Failed to generate HTN plan")\r\n    \r\n    def generate_htn_plan(self, task_description: str) > Optional[Dict]:\r\n        """Generate hierarchical task network plan"""\r\n        # Get environment context\r\n        context = self.get_environment_context()\r\n        \r\n        # First, determine the highlevel task type\r\n        task_type = self.identify_task_type(task_description)\r\n        \r\n        if task_type:\r\n            # Decompose into subtasks based on identified task type\r\n            plan = self.decompose_task(task_type, task_description, context)\r\n            return plan\r\n        else:\r\n            # Use GPT4o to figure out the task structure\r\n            return self.generate_plan_with_gpt(task_description, context)\r\n    \r\n    def identify_task_type(self, task_description: str) > Optional[str]:\r\n        """Identify the type of task from description"""\r\n        # Check against known task templates\r\n        for task_template, _ in self.task_templates.items():\r\n            # Simple keywordbased classification\r\n            keywords = {\r\n                "move_object": ["move", "transport", "carry", "place", "put"],\r\n                "assemble_objects": ["assemble", "build", "construct", "put together"],\r\n                "inspect_area": ["inspect", "check", "examine", "survey"]\r\n            }\r\n            \r\n            for keyword in keywords.get(task_template, []):\r\n                if keyword in task_description.lower():\r\n                    return task_template\r\n        \r\n        return None\r\n    \r\n    def decompose_task(self, task_type: str, task_description: str, context: Dict) > Dict:\r\n        """Decompose task into hierarchical subtasks"""\r\n        if task_type in self.task_templates:\r\n            template = self.task_templates[task_type]\r\n            \r\n            # Generate detailed plan based on template\r\n            plan = {\r\n                "task": task_description,\r\n                "task_type": task_type,\r\n                "tasks": [],\r\n                "context": context,\r\n                "timestamp": time.time()\r\n            }\r\n            \r\n            # Instantiate subtasks with appropriate parameters\r\n            for i, subtask_template in enumerate(template["subtasks"]):\r\n                subtask = self.instantiate_subtask(subtask_template, context, task_description)\r\n                subtask["id"] = i + 1\r\n                plan["tasks"].append(subtask)\r\n            \r\n            return plan\r\n        else:\r\n            # Fallback to GPT4o for unknown task types\r\n            return self.generate_plan_with_gpt(task_description, context)\r\n    \r\n    def instantiate_subtask(self, template: Dict, context: Dict, original_task: str) > Dict:\r\n        """Instantiate a subtask template with specific parameters"""\r\n        # Use GPT4o to determine specific parameters based on context\r\n        prompt = f"""\r\n        Task: {original_task}\r\n        \r\n        Environment Context: {json.dumps(context, indent=2)}\r\n        \r\n        Subtask Template: {json.dumps(template, indent=2)}\r\n        \r\n        Generate specific parameters for this subtask based on the environment context.\r\n        Return a JSON object with the subtask name and filledin parameters.\r\n        \r\n        Example:\r\n        {{\r\n          "name": "navigate_to_object",\r\n          "parameters": {{\r\n            "object_name": "red_cup",\r\n            "navigation_pose": {{ "x": 1.5, "y": 2.0, "theta": 0.0 }}\r\n          }},\r\n          "preconditions": ["robot_is_idle", "path_exists"],\r\n          "effects": ["robot_at_object", "object_in_view"]\r\n        }}\r\n        """\r\n        \r\n        try:\r\n            response = self.client.chat.completions.create(\r\n                model=self.model_name,\r\n                messages=[\r\n                    {\r\n                        "role": "system",\r\n                        "content": "You are an expert in robot task decomposition. Generate specific subtasks with concrete parameters based on environment context."\r\n                    },\r\n                    {\r\n                        "role": "user",\r\n                        "content": prompt\r\n                    }\r\n                ],\r\n                temperature=0.1,\r\n                max_tokens=1000\r\n            )\r\n            \r\n            response_text = response.choices[0].message.content.strip()\r\n            \r\n            # Extract JSON\r\n            if response_text.startswith(\'```\'):\r\n                start_idx = response_text.find(\'{\')\r\n                end_idx = response_text.rfind(\'}\') + 1\r\n                response_text = response_text[start_idx:end_idx]\r\n            \r\n            return json.loads(response_text)\r\n            \r\n        except Exception as e:\r\n            rospy.logerr(f"Error instantiating subtask: {e}")\r\n            # Return a basic template with generic parameters\r\n            return {\r\n                "name": template["name"],\r\n                "parameters": {param: f"<{param}>" for param in template.get("parameters", [])},\r\n                "preconditions": [],\r\n                "effects": []\r\n            }\r\n    \r\n    def generate_plan_with_gpt(self, task_description: str, context: Dict) > Optional[Dict]:\r\n        """Generate plan using GPT4o for unknown task types"""\r\n        prompt = f"""\r\n        Task: {task_description}\r\n        \r\n        Environment Context: {json.dumps(context, indent=2)}\r\n        \r\n        Available Actions:\r\n         move_to_location(location)\r\n         pick_object(object_name, grasp_type)\r\n         place_object(object_name, location)\r\n         navigate_to_object(object_name)\r\n         inspect_object(object_name)\r\n         open_container(container_name)\r\n         close_container(container_name)\r\n         detect_object(object_name)\r\n         transport_object(from_location, to_location)\r\n         assemble_parts(part1, part2)\r\n         disassemble_part(object)\r\n         charge_robot(at_charging_station)\r\n        \r\n        Generate a hierarchical task network plan for this task.\r\n        The plan should include:\r\n        1. Highlevel task decomposition\r\n        2. Specific subtasks with parameters\r\n        3. Precondition and effect definitions\r\n        4. Temporal dependencies between tasks\r\n        \r\n        Return as a JSON object with \'tasks\' array containing subtasks.\r\n        """\r\n        \r\n        try:\r\n            response = self.client.chat.completions.create(\r\n                model=self.model_name,\r\n                messages=[\r\n                    {\r\n                        "role": "system",\r\n                        "content": """Generate detailed hierarchical task networks for robotic tasks. \r\n                        Return valid JSON with a \'tasks\' array containing subtasks at different levels of abstraction. \r\n                        Each task should have name, parameters, preconditions, and effects."""\r\n                    },\r\n                    {\r\n                        "role": "user",\r\n                        "content": prompt\r\n                    }\r\n                ],\r\n                temperature=0.1,\r\n                max_tokens=1500\r\n            )\r\n            \r\n            response_text = response.choices[0].message.content.strip()\r\n            \r\n            # Extract JSON\r\n            if response_text.startswith(\'```\'):\r\n                start_idx = response_text.find(\'{\')\r\n                end_idx = response_text.rfind(\'}\') + 1\r\n                response_text = response_text[start_idx:end_idx]\r\n            \r\n            plan_data = json.loads(response_text)\r\n            plan_data["task"] = task_description\r\n            plan_data["task_type"] = "unknown_generated"\r\n            plan_data["context"] = context\r\n            plan_data["timestamp"] = time.time()\r\n            \r\n            return plan_data\r\n            \r\n        except Exception as e:\r\n            rospy.logerr(f"Error generating HTN plan: {e}")\r\n            return None\r\n    \r\n    def get_environment_context(self) > Dict:\r\n        """Get current environment context"""\r\n        # This would be populated from sensors in a real implementation\r\n        return {\r\n            "robot_pose": {"x": 0.0, "y": 0.0, "theta": 0.0},\r\n            "known_locations": [\r\n                {"name": "kitchen_table", "pose": {"x": 1.0, "y": 1.0, "theta": 0.0}},\r\n                {"name": "desk", "pose": {"x": 2.0, "y": 0.5, "theta": 0.0}},\r\n                {"name": "charging_station", "pose": {"x": 0.0, "y": 2.0, "theta": 1.57}}\r\n            ],\r\n            "detected_objects": [\r\n                {"name": "coffee_mug", "location": "kitchen_table", "properties": {"color": "white", "type": "container"}},\r\n                {"name": "notebook", "location": "desk", "properties": {"color": "black", "type": "stationery"}}\r\n            ],\r\n            "robot_capabilities": ["navigation", "manipulation", "grasping", "inspection"]\r\n        }\r\n\r\nif __name__ == \'__main__\':\r\n    api_key = rospy.get_param("~openai_api_key", "")\r\n    if not api_key:\r\n        api_key = input("Enter OpenAI API key: ")\r\n    \r\n    if not api_key:\r\n        rospy.logerr("No OpenAI API key provided!")\r\n        exit(1)\r\n    \r\n    planner = HTNPlanner(api_key)\r\n    planner.run()\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"lab-3-integrating-with-behavior-trees-for-execution",children:"Lab 3: Integrating with Behavior Trees for Execution"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Create a behavior tree execution system"})," (",(0,a.jsx)(n.code,{children:"behavior_tree_executor.py"}),"):","\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n\r\nimport py_trees\r\nimport py_trees.console as console\r\nimport rospy\r\nfrom std_msgs.msg import String, Bool\r\nfrom geometry_msgs.msg import Pose\r\nfrom actionlib_msgs.msg import GoalStatusArray\r\nfrom typing import Dict, List\r\nimport json\r\nimport time\r\n\r\nclass BTExecutionManager:\r\n    def __init__(self):\r\n        rospy.init_node(\'bt_execution_manager\', anonymous=True)\r\n        \r\n        # Publishers and Subscribers\r\n        self.status_pub = rospy.Publisher(\'/bt_execution_status\', String, queue_size=10)\r\n        self.feedback_pub = rospy.Publisher(\'/execution_feedback\', String, queue_size=10)\r\n        rospy.Subscriber(\'/htn_plan\', String, self.plan_callback)\r\n        rospy.Subscriber(\'/bt_control\', String, self.control_callback)\r\n        \r\n        # Execution state\r\n        self.root_behavior_tree = None\r\n        self.current_plan = None\r\n        self.execution_active = False\r\n        self.execution_start_time = 0\r\n        \r\n        rospy.loginfo("BT Execution Manager initialized")\r\n    \r\n    def plan_callback(self, msg: String):\r\n        """Handle incoming HTN plan"""\r\n        try:\r\n            plan = json.loads(msg.data)\r\n            self.current_plan = plan\r\n            \r\n            # Convert HTN plan to behavior tree\r\n            self.root_behavior_tree = self.convert_plan_to_bt(plan)\r\n            \r\n            if self.root_behavior_tree:\r\n                rospy.loginfo("Plan converted to behavior tree successfully")\r\n                self.publish_status("Plan ready for execution")\r\n                self.publish_status(f"Root BT: {self.root_behavior_tree.name}")\r\n            else:\r\n                rospy.logerr("Failed to convert plan to behavior tree")\r\n                self.publish_status("Plan conversion failed")\r\n                \r\n        except json.JSONDecodeError:\r\n            rospy.logerr("Failed to parse plan JSON")\r\n    \r\n    def control_callback(self, msg: String):\r\n        """Handle execution control commands"""\r\n        command = msg.data.lower().strip()\r\n        \r\n        if command == "start":\r\n            self.start_execution()\r\n        elif command == "stop":\r\n            self.stop_execution()\r\n        elif command == "pause":\r\n            self.pause_execution()\r\n        elif command == "resume":\r\n            self.resume_execution()\r\n        else:\r\n            rospy.logwarn(f"Unknown command: {command}")\r\n    \r\n    def convert_plan_to_bt(self, plan: Dict) > Optional[py_trees.behaviour.Behaviour]:\r\n        """Convert HTN plan to behavior tree"""\r\n        try:\r\n            # Create a sequence for the main plan\r\n            main_sequence = py_trees.composites.Sequence(name="MainPlan")\r\n            \r\n            # Add tasks to the sequence\r\n            for task in plan.get("tasks", []):\r\n                bt_task = self.create_task_behavior(task)\r\n                if bt_task:\r\n                    main_sequence.add_child(bt_task)\r\n            \r\n            return main_sequence\r\n            \r\n        except Exception as e:\r\n            rospy.logerr(f"Error converting plan to BT: {e}")\r\n            return None\r\n    \r\n    def create_task_behavior(self, task: Dict) > Optional[py_trees.behaviour.Behaviour]:\r\n        """Create a behavior tree node for a task"""\r\n        task_name = task.get("name", "unknown_task")\r\n        task_params = task.get("parameters", {})\r\n        \r\n        # Create appropriate behavior based on task name\r\n        if "navigate" in task_name:\r\n            return NavigationBehavior(task_name, **task_params)\r\n        elif "pick" in task_name or "grasp" in task_name:\r\n            return GraspingBehavior(task_name, **task_params)\r\n        elif "place" in task_name or "release" in task_name:\r\n            return PlacingBehavior(task_name, **task_params)\r\n        elif "inspect" in task_name:\r\n            return InspectionBehavior(task_name, **task_params)\r\n        elif "open" in task_name:\r\n            return OpenContainerBehavior(task_name, **task_params)\r\n        elif "close" in task_name:\r\n            return CloseContainerBehavior(task_name, **task_params)\r\n        elif "detect" in task_name:\r\n            return DetectionBehavior(task_name, **task_params)\r\n        elif "transport" in task_name:\r\n            return TransportBehavior(task_name, **task_params)\r\n        else:\r\n            # Generic task executor\r\n            return GenericTaskBehavior(task_name, task.get("action", "unknown"), task_params)\r\n    \r\n    def start_execution(self):\r\n        """Start executing the plan"""\r\n        if not self.root_behavior_tree:\r\n            rospy.logerr("No plan to execute")\r\n            self.publish_status("No plan to execute")\r\n            return\r\n        \r\n        self.execution_active = True\r\n        self.execution_start_time = time.time()\r\n        \r\n        # Setup tree\r\n        self.root_behavior_tree.setup_with_descendants()\r\n        \r\n        rate = rospy.Rate(10)  # 10 Hz\r\n        \r\n        rospy.loginfo("Starting plan execution...")\r\n        self.publish_status("Execution started")\r\n        \r\n        while self.execution_active and not rospy.is_shutdown():\r\n            try:\r\n                # Tick the tree\r\n                self.root_behavior_tree.tick_once()\r\n                \r\n                # Check for completion\r\n                if self.root_behavior_tree.status == py_trees.common.Status.SUCCESS:\r\n                    rospy.loginfo("Plan execution completed successfully!")\r\n                    self.publish_status("Execution completed successfully")\r\n                    self.execution_active = False\r\n                    break\r\n                elif self.root_behavior_tree.status == py_trees.common.Status.FAILURE:\r\n                    rospy.logerr("Plan execution failed!")\r\n                    self.publish_feedback({"status": "failure", "error": "Task failed"})\r\n                    self.publish_status("Execution failed")\r\n                    self.execution_active = False\r\n                    break\r\n                \r\n                # Publish feedback\r\n                self.publish_feedback({\r\n                    "status": "running",\r\n                    "tree_status": str(self.root_behavior_tree.status),\r\n                    "elapsed_time": time.time()  self.execution_start_time\r\n                })\r\n                \r\n                rate.sleep()\r\n                \r\n            except Exception as e:\r\n                rospy.logerr(f"Error during execution: {e}")\r\n                self.publish_status(f"Execution error: {e}")\r\n                self.stop_execution()\r\n                break\r\n    \r\n    def stop_execution(self):\r\n        """Stop plan execution"""\r\n        self.execution_active = False\r\n        if self.root_behavior_tree:\r\n            # Cancel any running actions\r\n            self.root_behavior_tree.stop(py_trees.common.Status.INVALID)\r\n        self.publish_status("Execution stopped")\r\n    \r\n    def pause_execution(self):\r\n        """Pause plan execution"""\r\n        self.execution_active = False\r\n        self.publish_status("Execution paused")\r\n    \r\n    def resume_execution(self):\r\n        """Resume plan execution"""\r\n        if self.root_behavior_tree:\r\n            self.execution_active = True\r\n            rospy.loginfo("Resuming plan execution...")\r\n            self.publish_status("Execution resumed")\r\n        else:\r\n            rospy.logwarn("No plan to resume")\r\n    \r\n    def publish_status(self, status: str):\r\n        """Publish execution status"""\r\n        status_msg = String()\r\n        status_msg.data = status\r\n        self.status_pub.publish(status_msg)\r\n    \r\n    def publish_feedback(self, feedback_data: Dict):\r\n        """Publish execution feedback"""\r\n        feedback_msg = String()\r\n        feedback_msg.data = json.dumps(feedback_data)\r\n        self.feedback_pub.publish(feedback_msg)\r\n\r\n# Behavior Tree Actions\r\nclass NavigationBehavior(py_trees.behaviour.Behaviour):\r\n    def __init__(self, name, location=None, navigation_pose=None, **kwargs):\r\n        super(NavigationBehavior, self).__init__(name)\r\n        self.location = location\r\n        self.navigation_pose = navigation_pose or {}\r\n        self.success_probability = kwargs.get("success_probability", 0.95)\r\n    \r\n    def setup(self, **kwargs):\r\n        self.logger.debug(f"NavigationBehavior [{self.name}].setup()") # Debug logger\r\n    \r\n    def update(self):\r\n        # Simulate navigation action\r\n        # In a real robot, this would call navigation stack or move_base\r\n        rospy.loginfo(f"Navigating to {self.location or self.navigation_pose}")\r\n        \r\n        # Simulate success/failure based on probability\r\n        if rospy.Time.now().to_sec() % 100 < (1  self.success_probability) * 100:\r\n            # Simulate occasional failure\r\n            self.feedback_message = "Navigation failed"\r\n            return py_trees.common.Status.FAILURE\r\n        else:\r\n            # Simulate time delay\r\n            rospy.sleep(1.0)\r\n            self.feedback_message = f"Reached {self.location or \'specified pose\'}"\r\n            return py_trees.common.Status.SUCCESS\r\n    \r\n    def terminate(self, new_status):\r\n        self.logger.debug(f"NavigationBehavior [{self.name}].terminate({new_status})")\r\n\r\nclass GraspingBehavior(py_trees.behaviour.Behaviour):\r\n    def __init__(self, name, object_name=None, grasp_pose=None, **kwargs):\r\n        super(GraspingBehavior, self).__init__(name)\r\n        self.object_name = object_name\r\n        self.grasp_pose = grasp_pose or {}\r\n        self.success_probability = kwargs.get("success_probability", 0.85)\r\n    \r\n    def setup(self, **kwargs):\r\n        self.logger.debug(f"GraspingBehavior [{self.name}].setup()")\r\n    \r\n    def update(self):\r\n        rospy.loginfo(f"Attempting to grasp {self.object_name}")\r\n        \r\n        # Simulate success/failure\r\n        import random\r\n        if random.random() > self.success_probability:\r\n            self.feedback_message = f"Failed to grasp {self.object_name}"\r\n            return py_trees.common.Status.FAILURE\r\n        else:\r\n            rospy.sleep(2.0)  # Simulate grasping time\r\n            self.feedback_message = f"Successfully grasped {self.object_name}"\r\n            return py_trees.common.Status.SUCCESS\r\n    \r\n    def terminate(self, new_status):\r\n        self.logger.debug(f"GraspingBehavior [{self.name}].terminate({new_status})")\r\n\r\nclass PlacingBehavior(py_trees.behaviour.Behaviour):\r\n    def __init__(self, name, object_name=None, placement_pose=None, **kwargs):\r\n        super(PlacingBehavior, self).__init__(name)\r\n        self.object_name = object_name\r\n        self.placement_pose = placement_pose or {}\r\n    \r\n    def setup(self, **kwargs):\r\n        self.logger.debug(f"PlacingBehavior [{self.name}].setup()")\r\n    \r\n    def update(self):\r\n        rospy.loginfo(f"Placing {self.object_name}")\r\n        rospy.sleep(1.5)  # Simulate placing time\r\n        self.feedback_message = f"Successfully placed {self.object_name}"\r\n        return py_trees.common.Status.SUCCESS\r\n    \r\n    def terminate(self, new_status):\r\n        self.logger.debug(f"PlacingBehavior [{self.name}].terminate({new_status})")\r\n\r\nclass InspectionBehavior(py_trees.behaviour.Behaviour):\r\n    def __init__(self, name, inspection_targets=None, **kwargs):\r\n        super(InspectionBehavior, self).__init__(name)\r\n        self.targets = inspection_targets or []\r\n    \r\n    def setup(self, **kwargs):\r\n        self.logger.debug(f"InspectionBehavior [{self.name}].setup()")\r\n    \r\n    def update(self):\r\n        rospy.loginfo(f"Inspecting targets: {self.targets}")\r\n        rospy.sleep(3.0)  # Simulate inspection time\r\n        self.feedback_message = f"Inspection complete for {len(self.targets)} targets"\r\n        return py_trees.common.Status.SUCCESS\r\n    \r\n    def terminate(self, new_status):\r\n        self.logger.debug(f"InspectionBehavior [{self.name}].terminate({new_status})")\r\n\r\n# Additional behaviors can be added similarly...\r\n\r\nclass GenericTaskBehavior(py_trees.behaviour.Behaviour):\r\n    def __init__(self, name, action_type="unknown", parameters=None):\r\n        super(GenericTaskBehavior, self).__init__(name)\r\n        self.action_type = action_type\r\n        self.parameters = parameters or {}\r\n    \r\n    def setup(self, **kwargs):\r\n        self.logger.debug(f"GenericTaskBehavior [{self.name}].setup()")\r\n    \r\n    def update(self):\r\n        rospy.loginfo(f"Executing generic task: {self.action_type} with params: {self.parameters}")\r\n        rospy.sleep(1.0)  # Simulate task execution\r\n        self.feedback_message = f"Completed {self.action_type}"\r\n        return py_trees.common.Status.SUCCESS\r\n    \r\n    def terminate(self, new_status):\r\n        self.logger.debug(f"GenericTaskBehavior [{self.name}].terminate({new_status})")\r\n\r\ndef main():\r\n    manager = BTExecutionManager()\r\n    \r\n    try:\r\n        rospy.spin()\r\n    except KeyboardInterrupt:\r\n        rospy.loginfo("Shutting down BT Execution Manager")\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"runnable-code-example",children:"Runnable Code Example"}),"\n",(0,a.jsx)(n.p,{children:"Here's a complete system that ties GPTbased planning with behavior tree execution:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n# complete_cognitive_planning_system.py\r\n\r\nimport openai\r\nimport json\r\nimport rospy\r\nimport py_trees\r\nfrom std_msgs.msg import String, Bool\r\nfrom geometry_msgs.msg import Pose\r\nfrom actionlib_msgs.msg import GoalStatusArray\r\nimport time\r\nimport threading\r\nimport queue\r\n\r\nclass CompleteCognitivePlanningSystem:\r\n    """Complete cognitive planning system using GPT4o and behavior trees"""\r\n    \r\n    def __init__(self, api_key: str):\r\n        # Initialize OpenAI client\r\n        self.client = openai.OpenAI(api_key=api_key)\r\n        self.model_name = "gpt4o"\r\n        \r\n        # Initialize ROS\r\n        rospy.init_node(\'complete_cognitive_planner\', anonymous=True)\r\n        \r\n        # Publishers and Subscribers\r\n        self.plan_pub = rospy.Publisher(\'/complete_plan\', String, queue_size=10)\r\n        self.status_pub = rospy.Publisher(\'/cognitive_planner_status\', String, queue_size=10)\r\n        self.feedback_pub = rospy.Publisher(\'/cognitive_feedback\', String, queue_size=10)\r\n        self.bt_command_pub = rospy.Publisher(\'/bt_control\', String, queue_size=10)\r\n        \r\n        rospy.Subscriber(\'/cognitive_task\', String, self.task_callback)\r\n        rospy.Subscriber(\'/cognitive_status\', String, self.status_feedback_callback)\r\n        \r\n        # Internal state\r\n        self.active_plan = None\r\n        self.plan_queue = queue.Queue()\r\n        self.execution_thread = None\r\n        self.is_executing = False\r\n        \r\n        # System parameters\r\n        self.max_plan_steps = 50  # Prevent infinite plans\r\n        self.default_success_probability = 0.9\r\n        self.max_replanning_attempts = 3\r\n        \r\n        rospy.loginfo("Complete Cognitive Planning System initialized")\r\n    \r\n    def task_callback(self, msg: String):\r\n        """Handle incoming cognitive tasks"""\r\n        rospy.loginfo(f"Received cognitive task: {msg.data}")\r\n        \r\n        # Generate plan using GPT4o\r\n        plan = self.generate_cognitive_plan(msg.data)\r\n        \r\n        if plan:\r\n            self.active_plan = plan\r\n            rospy.loginfo(f"Generated plan with {len(plan.get(\'tasks\', []))} steps")\r\n            \r\n            # Publish plan for BT execution\r\n            plan_msg = String()\r\n            plan_msg.data = json.dumps(plan, indent=2)\r\n            self.plan_pub.publish(plan_msg)\r\n            \r\n            # Trigger execution\r\n            self.start_execution()\r\n        else:\r\n            rospy.logerr("Failed to generate cognitive plan")\r\n            self.publish_status("Plan generation failed")\r\n    \r\n    def status_feedback_callback(self, msg: String):\r\n        """Handle feedback from execution system"""\r\n        try:\r\n            feedback = json.loads(msg.data)\r\n            status = feedback.get(\'status\', \'\')\r\n            \r\n            if status == \'failure\':\r\n                rospy.loginfo("Plan execution failed, attempting replanning")\r\n                self.handle_execution_failure(feedback)\r\n            elif status == \'success\':\r\n                rospy.loginfo("Plan execution completed successfully")\r\n                self.publish_status("Plan execution completed")\r\n            elif status == \'running\':\r\n                progress = feedback.get(\'progress\', 0)\r\n                self.publish_status(f"Execution in progress: {progress}%")\r\n        except json.JSONDecodeError:\r\n            rospy.logerr("Failed to parse status feedback")\r\n    \r\n    def generate_cognitive_plan(self, task_description: str) > dict:\r\n        """Generate cognitive plan using GPT4o"""\r\n        # Get environment context\r\n        context = self.get_environment_context()\r\n        \r\n        # Construct detailed planning prompt\r\n        prompt = f"""\r\n        Task: {task_description}\r\n        \r\n        Environment Context: {json.dumps(context, indent=2)}\r\n        \r\n        Available Robot Capabilities:\r\n         Navigation: Move to locations, avoid obstacles\r\n         Manipulation: Pick/place objects, open/close containers\r\n         Perception: Detect objects, inspect areas, recognize faces\r\n         Communication: Speak, listen, interact with humans\r\n         Learning: Adapt to new situations, remember preferences\r\n        \r\n        HighLevel Actions:\r\n         move_to(location): Navigate to named location\r\n         pick_object(object, grasp_type): Grasp an object\r\n         place_object(object, location): Place object at location\r\n         detect_object(object_type): Find an object in the environment\r\n         navigate_to_object(object_type): Move near an object\r\n         open_container(container): Open a door or drawer\r\n         close_container(container): Close a door or drawer\r\n         inspect_area(area): Survey a specific area\r\n         interact_with_person(person): Approach and talk to someone\r\n         find_person(person_name): Locate a specific person\r\n         deliver_object(object, recipient): Transport and hand over object\r\n         charge_robot(): Return to charging station\r\n         wait_for(time_period): Pause execution\r\n        \r\n        Generate a comprehensive cognitive plan that:\r\n        1. Breaks down the task into logical highlevel steps\r\n        2. Considers environmental context and constraints\r\n        3. Accounts for robot capabilities and limitations\r\n        4. Includes error handling and recovery strategies\r\n        5. Estimates time and resource requirements\r\n        6. Specifies success conditions for each step\r\n        \r\n        Return as JSON with structure:\r\n        {{\r\n          "task": "original task description",\r\n          "reasoning": "stepbystep reasoning for the plan",\r\n          "plan": [\r\n            {{\r\n              "step_id": 1,\r\n              "description": "what this step accomplishes",\r\n              "action": "high_level_action",\r\n              "parameters": {{"param1": "value1", "param2": "value2"}},\r\n              "context_requirements": ["condition1", "condition2"],\r\n              "expected_outcomes": ["outcome1", "outcome2"],\r\n              "timeout": 30,  # seconds\r\n              "success_probability": 0.95,\r\n              "recovery_plan": ["alternative_step1", "alternative_step2"]\r\n            }}\r\n          ],\r\n          "estimated_total_time": 180,  # seconds\r\n          "confidence": 0.85,\r\n          "constraints": ["constraint1", "constraint2"]\r\n        }}\r\n        """\r\n        \r\n        try:\r\n            response = self.client.chat.completions.create(\r\n                model=self.model_name,\r\n                messages=[\r\n                    {\r\n                        "role": "system",\r\n                        "content": """Generate detailed cognitive plans for robotic tasks. \r\n                        Each plan should be comprehensive, considering environmental context, \r\n                        robot capabilities, and potential failure modes. \r\n                        Return only valid JSON as specified."""\r\n                    },\r\n                    {\r\n                        "role": "user",\r\n                        "content": prompt\r\n                    }\r\n                ],\r\n                temperature=0.1,\r\n                max_tokens=3000\r\n            )\r\n            \r\n            response_text = response.choices[0].message.content.strip()\r\n            \r\n            # Extract JSON\r\n            if response_text.startswith(\'```\'):\r\n                start_idx = response_text.find(\'{\')\r\n                end_idx = response_text.rfind(\'}\') + 1\r\n                response_text = response_text[start_idx:end_idx]\r\n            \r\n            plan_data = json.loads(response_text)\r\n            \r\n            # Validate plan structure\r\n            if self.validate_plan(plan_data):\r\n                rospy.loginfo(f"Generated valid cognitive plan with {len(plan_data[\'plan\'])} steps")\r\n                return plan_data\r\n            else:\r\n                rospy.logerr("Generated plan failed validation")\r\n                return {}\r\n        except Exception as e:\r\n            rospy.logerr(f"Error generating cognitive plan: {e}")\r\n            return {}\r\n    \r\n    def validate_plan(self, plan: dict) > bool:\r\n        """Validate the structure of a generated plan"""\r\n        required_fields = [\'task\', \'plan\', \'confidence\']\r\n        if not all(field in plan for field in required_fields):\r\n            rospy.logwarn("Plan missing required fields")\r\n            return False\r\n        \r\n        if not isinstance(plan[\'plan\'], list):\r\n            rospy.logwarn("Plan steps not in list format")\r\n            return False\r\n        \r\n        if len(plan[\'plan\']) > self.max_plan_steps:\r\n            rospy.logwarn(f"Plan exceeds maximum step count ({self.max_plan_steps})")\r\n            return False\r\n        \r\n        # Validate each step\r\n        for i, step in enumerate(plan[\'plan\']):\r\n            required_step_fields = [\'step_id\', \'action\', \'parameters\']\r\n            if not all(field in step for field in required_step_fields):\r\n                rospy.logwarn(f"Step {i} missing required fields")\r\n                return False\r\n        \r\n        if not (0.0 <= plan.get(\'confidence\', 0.5) <= 1.0):\r\n            rospy.logwarn("Plan confidence out of range [0,1]")\r\n            return False\r\n        \r\n        return True\r\n    \r\n    def get_environment_context(self) > dict:\r\n        """Get current environment context for planning"""\r\n        # This would be populated from various sensors and state topics in a real system\r\n        return {\r\n            "robot_state": {\r\n                "current_location": "charging_station",\r\n                "battery_level": 0.75,\r\n                "gripper_status": "open",\r\n                "arm_position": "home",\r\n                "navigation_status": "ready"\r\n            },\r\n            "known_locations": [\r\n                {"name": "kitchen", "coordinates": [1.0, 1.0]},\r\n                {"name": "living_room", "coordinates": [2.0, 0.5]},\r\n                {"name": "bedroom", "coordinates": [0.5, 2.0]},\r\n                {"name": "office", "coordinates": [1.5, 2.5]},\r\n                {"name": "charging_station", "coordinates": [0.0, 0.0]}\r\n            ],\r\n            "detected_objects": [\r\n                {"name": "red_apple", "type": "fruit", "location": "kitchen", "pose": [1.1, 1.1]},\r\n                {"name": "blue_book", "type": "stationery", "location": "living_room", "pose": [2.1, 0.6]},\r\n                {"name": "white_cup", "type": "container", "location": "kitchen", "pose": [1.2, 1.0]}\r\n            ],\r\n            "known_people": [\r\n                {"name": "john", "location": "office", "last_seen": "20231015T10:30:00Z"},\r\n                {"name": "mary", "location": "kitchen", "last_seen": "20231015T10:25:00Z"}\r\n            ],\r\n            "time_context": {\r\n                "hour_of_day": 10,  # 24hour format\r\n                "day_of_week": "monday",\r\n                "month": "october",\r\n                "is_daylight": True\r\n            },\r\n            "environment_constraints": {\r\n                "fragile_objects": ["glassware", "electronics"],\r\n                "restricted_areas": ["private_office"],\r\n                "noise_limitations": ["during_meeting_hours"],\r\n                "charging_deadline": "20231015T18:00:00Z"\r\n            }\r\n        }\r\n    \r\n    def start_execution(self):\r\n        """Start executing the current plan"""\r\n        if not self.active_plan or self.is_executing:\r\n            return\r\n        \r\n        rospy.loginfo("Starting cognitive plan execution")\r\n        self.is_executing = True\r\n        self.publish_status("Plan execution started")\r\n        \r\n        # Publish to BT executor\r\n        plan_msg = String()\r\n        plan_msg.data = json.dumps(self.active_plan, indent=2)\r\n        self.plan_pub.publish(plan_msg)\r\n        \r\n        # Send start command to BT executor\r\n        start_cmd = String()\r\n        start_cmd.data = "start"\r\n        self.bt_command_pub.publish(start_cmd)\r\n    \r\n    def handle_execution_failure(self, feedback: dict):\r\n        """Handle plan execution failure with recovery"""\r\n        step_failed = feedback.get(\'step\', 0)\r\n        error = feedback.get(\'error\', \'unknown\')\r\n        \r\n        rospy.loginfo(f"Handling failure at step {step_failed}: {error}")\r\n        self.publish_status(f"Failure at step {step_failed}: {error}")\r\n        \r\n        # Attempt recovery up to max attempts\r\n        attempts = 0\r\n        while attempts < self.max_replanning_attempts:\r\n            recovery_plan = self.generate_recovery_plan(step_failed, error)\r\n            \r\n            if recovery_plan:\r\n                rospy.loginfo(f"Recovery plan generated (attempt {attempts + 1})")\r\n                \r\n                # Update active plan with recovery plan\r\n                self.active_plan = recovery_plan\r\n                \r\n                # Restart execution\r\n                self.start_execution()\r\n                return\r\n            else:\r\n                attempts += 1\r\n                rospy.logwarn(f"Recovery attempt {attempts} failed, trying again...")\r\n        \r\n        # If all recovery attempts fail\r\n        rospy.logerr(f"All {self.max_replanning_attempts} recovery attempts failed")\r\n        self.publish_status(f"Recovery failed after {self.max_replanning_attempts} attempts")\r\n        self.is_executing = False\r\n    \r\n    def generate_recovery_plan(self, failed_step: int, error: str) > dict:\r\n        """Generate a recovery plan using GPT4o"""\r\n        context = self.get_environment_context()\r\n        \r\n        prompt = f"""\r\n        Original Task: {self.active_plan[\'task\']}\r\n        \r\n        Failed Step: {failed_step}\r\n        Error: {error}\r\n        Current Environment: {json.dumps(context, indent=2)}\r\n        \r\n        Available Recovery Strategies:\r\n         Retry step with different parameters\r\n         Skip problematic step if possible\r\n         Alternative approach to achieve same goal\r\n         Abort task and return to safe state\r\n         Request human assistance\r\n         Charge robot if battery is low\r\n        \r\n        Generate a recovery plan that addresses the specific failure and attempts to continue task completion.\r\n        The recovery plan should:\r\n        1. Address the immediate failure\r\n        2. Adapt the overall strategy if needed\r\n        3. Consider current environment state\r\n        4. Be executable by the robot\r\n        \r\n        Return in the same JSON format as the original plan.\r\n        """\r\n        \r\n        try:\r\n            response = self.client.chat.completions.create(\r\n                model=self.model_name,\r\n                messages=[\r\n                    {\r\n                        "role": "system",\r\n                        "content": "Generate recovery plans for failed robotic tasks. Return valid JSON with a complete plan structure."\r\n                    },\r\n                    {\r\n                        "role": "user",\r\n                        "content": prompt\r\n                    }\r\n                ],\r\n                temperature=0.2,\r\n                max_tokens=2500\r\n            )\r\n            \r\n            response_text = response.choices[0].message.content.strip()\r\n            \r\n            # Extract JSON\r\n            if response_text.startswith(\'```\'):\r\n                start_idx = response_text.find(\'{\')\r\n                end_idx = response_text.rfind(\'}\') + 1\r\n                response_text = response_text[start_idx:end_idx]\r\n            \r\n            recovery_plan = json.loads(response_text)\r\n            \r\n            if self.validate_plan(recovery_plan):\r\n                return recovery_plan\r\n            else:\r\n                rospy.logerr("Recovery plan failed validation")\r\n                return {}\r\n                \r\n        except Exception as e:\r\n            rospy.logerr(f"Error generating recovery plan: {e}")\r\n            return {}\r\n    \r\n    def publish_status(self, status: str):\r\n        """Publish system status"""\r\n        status_msg = String()\r\n        status_msg.data = status\r\n        self.status_pub.publish(status_msg)\r\n    \r\n    def run(self):\r\n        """Run the cognitive planning system"""\r\n        rospy.loginfo("Cognitive Planning System running...")\r\n        rospy.spin()\r\n\r\ndef main():\r\n    """Main function to run the complete system"""\r\n    api_key = input("Enter OpenAI API key: ")\r\n    if not api_key:\r\n        rospy.logerr("No API key provided!")\r\n        return\r\n    \r\n    system = CompleteCognitivePlanningSystem(api_key)\r\n    system.run()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"miniproject",children:"Miniproject"}),"\n",(0,a.jsx)(n.p,{children:"Create a complete cognitive planning system that:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Implements GPT4obased hierarchical task planning"}),"\n",(0,a.jsx)(n.li,{children:"Integrates with behavior tree execution for plan execution"}),"\n",(0,a.jsx)(n.li,{children:"Handles complex multistep tasks with dependencies"}),"\n",(0,a.jsx)(n.li,{children:"Implements plan monitoring and execution feedback"}),"\n",(0,a.jsx)(n.li,{children:"Creates contextaware planning considering environment state"}),"\n",(0,a.jsx)(n.li,{children:"Implements recovery mechanisms for plan failures"}),"\n",(0,a.jsx)(n.li,{children:"Evaluates the quality and efficiency of generated plans"}),"\n",(0,a.jsx)(n.li,{children:"Demonstrates the system with complex multirobot scenarios"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Your project should include:\r\nComplete GPT4o integration for cognitive planning\r\nBehavior tree execution system\r\nContextaware environment model\r\nPlan monitoring and feedback mechanisms\r\nRecovery and replanning capabilities\r\nPerformance evaluation metrics\r\nDemo scenarios with complex tasks"}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"This chapter covered cognitive task planning using GPT4o for robotics:"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Cognitive Planning"}),": Highlevel reasoning about complex robotic tasks\r\n",(0,a.jsx)(n.strong,{children:"GPT4o Integration"}),": Using large language models for plan generation\r\n",(0,a.jsx)(n.strong,{children:"Hierarchical Decomposition"}),": Breaking complex tasks into manageable subtasks\r\n",(0,a.jsx)(n.strong,{children:"Behavior Trees"}),": Executing plans with robust control structures\r\n",(0,a.jsx)(n.strong,{children:"Context Awareness"}),": Adapting plans based on environment state\r\n",(0,a.jsx)(n.strong,{children:"Recovery Mechanisms"}),": Handling failures and adapting plans\r\n",(0,a.jsx)(n.strong,{children:"Performance Evaluation"}),": Assessing plan quality and execution success"]}),"\n",(0,a.jsx)(n.p,{children:"Cognitive task planning with LLMs represents a significant advancement in robotics, enabling robots to understand complex tasks expressed in natural language and decompose them into executable actions while considering environmental context and potential failure modes."})]})}function _(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);